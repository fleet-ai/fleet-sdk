{
    "problems": [
        {
            "id": "give-me-more-tasks",
            "problem": "In the engineering project, can you move all the bugs to sprint 3, assign the data pipeline bug to me, and assign all the other bugs to Raj?",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_give_me_more_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that bugs are moved to sprint 3 and assigned correctly\"\"\"\n    # Get user IDs\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n\n    raj_id = raj_user[\"id\"]\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify SCRUM-555 (data pipeline bug) is assigned to Sarah Kim\n    after.table(\"issues\").eq(\"id\", \"SCRUM-555\").assert_eq(\"owner\", sarah_kim_id)\n\n    # Verify other bugs are assigned to Sarah Kim\n    other_bugs = [\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-790\",\n        \"SCRUM-822\",\n        \"SCRUM-882\",\n        \"SCRUM-897\",\n        \"SCRUM-956\",\n        \"SCRUM-1331\",\n        \"SCRUM-1312\",\n        \"SCRUM-1210\",\n        \"SCRUM-1230\",\n        \"SCRUM-1282\",\n    ]\n    for bug_id in other_bugs:\n        after.table(\"issues\").eq(\"id\", bug_id).assert_eq(\"owner\", raj_id)\n\n    # Verify all bugs are in sprint_3\n    all_bugs = [\"SCRUM-555\"] + other_bugs\n    for bug_id in all_bugs:\n        after.table(\"sprint_issues\").eq(\"issue_id\", bug_id).assert_eq(\n            \"sprint_id\", \"sprint_3\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Assignment changes\n    expected_changes.append(\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-555\",\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        }\n    )\n\n    for bug_id in other_bugs:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": bug_id,\n                \"field\": \"owner\",\n                \"after\": raj_id,\n            }\n        )\n\n    # Sprint changes\n    for bug_id in all_bugs:\n        # Remove from previous sprint\n        before_assignment = before.table(\"sprint_issues\").eq(\"issue_id\", bug_id).first()\n        if before_assignment:\n            old_sprint = before_assignment.get(\"sprint_id\")\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (old_sprint, bug_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        # Add to sprint_3\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_3\", bug_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "convert-to-exponential-story-points",
            "problem": "We're converting into a new system where we're now measuring story points in exponentials (1, 2, 4, 8, 16, etc). Can you round all of my active, planned, and backlogged issues to the nearest exponential story point, rounding up if equidistant, in platform eng?",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_convert_to_exponential_story_points(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate conversion of story points to exponential values (1, 2, 4, 8, 16, etc)\"\"\"\n\n    def is_exponential_of_2(n):\n        \"\"\"Check if n is a power of 2 (1, 2, 4, 8, 16, ...)\"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n\n    def next_exponential(n):\n        \"\"\"Round to nearest exponential (power of 2), rounding up when equidistant\"\"\"\n        if n <= 0:\n            return 1\n        if is_exponential_of_2(n):\n            return n\n\n        # Find the two surrounding powers of 2\n        lower_power = 1\n        while lower_power < n:\n            lower_power *= 2\n        upper_power = lower_power\n        lower_power //= 2\n\n        # Calculate distances to both powers\n        distance_to_lower = n - lower_power\n        distance_to_upper = upper_power - n\n\n        # Round to nearest, with tie-breaking towards higher value\n        if distance_to_lower < distance_to_upper:\n            return lower_power\n        else:  # distance_to_lower >= distance_to_upper (includes equidistant case)\n            return upper_power\n\n    # Get user ID for Sarah Kim\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Get issues that should have been converted (only for Sarah Kim)\n    issues_with_points = (\n        after.table(\"issues\")\n        .neq(\"issue_type\", \"Epic\")\n        .neq(\"issue_type\", \"Subtask\")\n        .eq(\"project_key\", \"SCRUM\")\n        .eq(\"owner\", sarah_kim_id)\n        .not_null(\"story_points\")\n        .all()\n    )\n\n    expected_changes = []\n    conversion_count = 0\n\n    for issue in issues_with_points:\n        issue_id = issue.get(\"id\")\n        new_points = issue.get(\"story_points\")\n\n        # Get original story points from before snapshot\n        original_issue = before.table(\"issues\").eq(\"id\", issue_id).first()\n        if not original_issue:\n            continue  # Skip new issues\n\n        original_points = original_issue.get(\"story_points\")\n        if original_points is None:\n            continue  # Skip issues that didn't have points originally\n\n        # Verify the conversion is correct\n        expected_points = next_exponential(original_points)\n\n        if new_points != expected_points:\n            raise AssertionError(\n                f\"Issue {issue_id}: Expected story points {expected_points} \"\n                f\"(rounded up from {original_points}), got {new_points}\"\n            )\n\n        # Verify it's an exponential value\n        if not is_exponential_of_2(new_points):\n            raise AssertionError(\n                f\"Issue {issue_id}: Story points {new_points} is not an exponential value\"\n            )\n\n        # Only track as a change if the value actually changed\n        if original_points != new_points:\n            expected_changes.append(\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"story_points\",\n                    \"after\": new_points,\n                }\n            )\n            conversion_count += 1\n\n    if conversion_count == 0:\n        raise AssertionError(\n            \"No story points were converted - expected at least some conversions\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only story points changed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "restructure-onboarding-epics",
            "problem": "I want to restructure my platform engineering project. Specifically, I have 5 epics related to onboarding (one for self-serve onboarding portal, one for customer success guided, one for design, one for developing onboarding tools, and one to test and launch). Create a new epic in the platform engineering simply named \"Onboarding\" with a description in my current sprint 1, and then move all of the issues sitting under the 5 epics enumerated in this message into this new Onboarding epic",
            "category": "epic_management_and_organization",
            "difficulty": "hard",
            "verifier_func": "async def validate_restructure_onboarding_epics(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of master 'Onboarding' epic SCRUM-1340 in sprint_1 with all onboarding issues moved under it\"\"\"\n    # Check that SCRUM-1340 exists as an Epic in sprint_1\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"name\", \"Onboarding\")\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1340\").eq(\n        \"sprint_id\", \"sprint_1\"\n    ).assert_exists()\n\n    # Define all the onboarding-related issue IDs that should be under this epic\n    onboarding_issue_ids = [\n        \"SCRUM-766\",\n        \"SCRUM-773\",\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-831\",\n        \"SCRUM-835\",\n        \"SCRUM-839\",\n        \"SCRUM-843\",\n        \"SCRUM-1263\",\n        \"SCRUM-1269\",\n        \"SCRUM-1275\",\n        \"SCRUM-1282\",\n        \"SCRUM-1283\",\n        \"SCRUM-1291\",\n        \"SCRUM-1298\",\n        \"SCRUM-1305\",\n        \"SCRUM-1312\",\n        \"SCRUM-1313\",\n        \"SCRUM-1320\",\n        \"SCRUM-1331\",\n        \"SCRUM-1332\",\n        \"SCRUM-1336\",\n    ]\n\n    # Check that all specified issues have epic_id set to SCRUM-1340\n    for issue_id in onboarding_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + sprint assignment + all issue parent assignments\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"},\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", \"SCRUM-1340\"),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Add epic_id changes for all onboarding issues\n    for issue_id in onboarding_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"SCRUM-1340\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "blocked-by-typescript-migration",
            "problem": "Unfortunately we have to complete our typescript migration before making any more frontend UI improvements. Go into the platform engineering project and find all issues labeled as \"Frontend\". Review every issue; if the issue is not marked as Done, tag the issue as blocked by my typescript migraiton and type safety epic. Ignore any issue marked as Done.",
            "category": "dependency_and_blocking_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_blocked_by_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that frontend issues are blocked by DEBT-793\"\"\"\n    expected_blocked_issues = [\n        \"SCRUM-1269\",\n        \"SCRUM-711\",\n        \"SCRUM-1312\",\n        \"SCRUM-726\",\n        \"SCRUM-855\",\n        \"SCRUM-942\",\n        \"SCRUM-943\",\n        \"SCRUM-1298\",\n        \"SCRUM-731\",\n        \"SCRUM-738\",\n        \"SCRUM-745\",\n        \"SCRUM-753\",\n        \"SCRUM-759\",\n        \"SCRUM-766\",\n        \"SCRUM-773\",\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-782\",\n        \"SCRUM-790\",\n        \"SCRUM-814\",\n        \"SCRUM-823\",\n    ]\n\n    expected_changes = []\n\n    for issue_id in expected_blocked_issues:\n        relationship = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", \"DEBT-793\")\n            .eq(\"target_issue_id\", issue_id)\n            .eq(\"relationship_type\", \"blocks\")\n            .first()\n        )\n\n        if not relationship:\n            raise AssertionError(f\"Expected {issue_id} to be blocked by DEBT-793\")\n\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "comment-on-all-unreplied-issues",
            "problem": "For all support issues in progress where the user hasn't heard from us in >1 day, can you add a comment letting them know we're still on it? To check when the user last heard from us, you may need to scroll down through the issue to see the full back-and-forth.",
            "category": "comments_and_communication",
            "difficulty": "hard",
            "verifier_func": "async def validate_comment_on_all_unreplied_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify multiple support issues have the expected comment counts\"\"\"\n    # Expected comment counts for each issue\n    expected_counts = {\n        \"SUP-404\": 9,\n        \"SUP-407\": 6,\n        \"SUP-410\": 5,\n        \"SUP-417\": 5,\n        \"SUP-430\": 3,\n        \"SUP-435\": 3,\n        \"SUP-442\": 6,\n        \"SUP-445\": 9,\n        \"SUP-499\": 5,\n    }\n\n    new_comment_ids = []\n\n    for issue_id, expected_count in expected_counts.items():\n        # Count public comments for this issue\n        comment_count = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != expected_count:\n            raise AssertionError(\n                f\"Expected {expected_count} public comments on {issue_id}, found {comment_count}\"\n            )\n\n        # Verify exactly one new comment was added\n        before_count = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != before_count + 1:\n            raise AssertionError(\n                f\"Expected comment count to increase by 1 for {issue_id}. Before: {before_count}, After: {comment_count}\"\n            )\n\n        # Find the new comment for this issue\n        all_after_comments = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n        all_before_comments = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n\n        before_ids = {comment[\"id\"] for comment in all_before_comments}\n        new_comments = [\n            comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n        ]\n\n        if len(new_comments) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 new comment for {issue_id}, found {len(new_comments)}\"\n            )\n\n        new_comment_ids.append(new_comments[0][\"id\"])\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes for all new comments\n    expected_changes = [\n        {\n            \"table\": \"activities\",\n            \"pk\": comment_id,\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n        for comment_id in new_comment_ids\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-workflow-implemented-tasks",
            "problem": "Can you create an associated issue in the platform engineering project for each of these support tickets: 1) duplicate workflows; 2) export workflow templates; 3) bulk edit workflows; 4) search workflows by content; 5) version control workflows; 6) and real-time collaboration for workflows in product eng? Put it under a new epic, and set each support ticket as implemented by each issue.",
            "category": "task_creation_and_subtask_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_create_workflow_implemented_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that SCRUM-1340 through SCRUM-1345 exist with one epic and implementation relationships\"\"\"\n    issue_ids = [\n        \"SCRUM-1340\",\n        \"SCRUM-1341\",\n        \"SCRUM-1342\",\n        \"SCRUM-1343\",\n        \"SCRUM-1344\",\n        \"SCRUM-1345\",\n        \"SCRUM-1346\",\n    ]\n    support_tickets = [\"SUP-386\", \"SUP-392\", \"SUP-397\", \"SUP-409\", \"SUP-414\", \"SUP-419\"]\n\n    # Verify all issues exist\n    issues = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Expected issue {issue_id} to exist\")\n        issues.append(issue)\n\n    # Find the epic (one issue should have issue_type = \"Epic\")\n    epic_issues = [issue for issue in issues if issue.get(\"issue_type\") == \"Epic\"]\n    if len(epic_issues) != 1:\n        raise AssertionError(f\"Expected exactly 1 epic, found {len(epic_issues)}\")\n\n    epic = epic_issues[0]\n    epic_id = epic[\"id\"]\n\n    # Verify other 5 issues have epic_id pointing to the epic\n    non_epic_issues = [issue for issue in issues if issue.get(\"issue_type\") != \"Epic\"]\n    if len(non_epic_issues) != 6:\n        raise AssertionError(\n            f\"Expected exactly 6 non-epic issues, found {len(non_epic_issues)}\"\n        )\n\n    for issue in non_epic_issues:\n        if issue.get(\"epic_id\") != epic_id:\n            raise AssertionError(\n                f\"Expected issue {issue['id']} to have epic_id {epic_id}, got {issue.get('epic_id')}\"\n            )\n\n    # Verify each support ticket is implemented by exactly one issue (no duplicates)\n    implementation_relationships = []\n    used_issues = set()\n\n    for support_ticket in support_tickets:\n        relationships = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", support_ticket)\n            .eq(\"relationship_type\", \"is_implemented_by\")\n            .all()\n        )\n\n        if len(relationships) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 implementation relationship for {support_ticket}, found {len(relationships)}\"\n            )\n\n        rel = relationships[0]\n        implementing_issue = rel[\"target_issue_id\"]\n\n        if implementing_issue not in issue_ids:\n            raise AssertionError(\n                f\"Expected {support_ticket} to be implemented by one of {issue_ids}, got {implementing_issue}\"\n            )\n\n        if implementing_issue in used_issues:\n            raise AssertionError(\n                f\"Issue {implementing_issue} is implementing multiple support tickets (duplicates not allowed)\"\n            )\n\n        used_issues.add(implementing_issue)\n        implementation_relationships.append(rel)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected changes - 6 new issues and 6 implementation relationships\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    for rel in implementation_relationships:\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": rel[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "schedule-offline-ui-bugs",
            "problem": "Can you set the issue fix offline mode UI bugs to start in 4 days and to last for 3 days in the timeline view?",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_schedule_offline_ui_bugs(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate scheduling of offline UI bugs issue (SCRUM-1210)\"\"\"\n    issue_id = \"SCRUM-1210\"\n\n    # Get the issue\n    issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n    if not issue:\n        raise AssertionError(f\"Issue {issue_id} not found\")\n\n    hours_ago = issue.get(\"hoursAgo\")\n    duration = issue.get(\"duration\")\n\n    # Validate hoursAgo is -96 (starts in 4 days)\n    if hours_ago != -96:\n        raise AssertionError(\n            f\"Expected hoursAgo as -96 for {issue_id}, got {hours_ago}\"\n        )\n\n    # Validate duration is 72 hours (3 days)\n    if duration != 72:\n        raise AssertionError(\n            f\"Expected duration between 48 and 72 hours for {issue_id}, got {duration}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the scheduling fields changed\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"hoursAgo\",\n                \"after\": hours_ago,\n            },\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"duration\", \"after\": duration},\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "plan-cicd-pipeline-epic",
            "problem": "Can you plan the CI/CD Pipeline Optimization epic? Go to the timeline of the Platform Engineering project, and locate this epic. Considering the blue line marks today in this timeline, use that as a guide to start this epic one week from today and to have it last 15 days. Each of the 5 issues within this epic should also start within this 15 day range, and each task should last 3 days each without any overlap.",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_plan_cicd_pipeline_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning of CI/CD Pipeline Optimization epic (SCRUM-523) and its child issues\"\"\"\n    epic_id = \"SCRUM-523\"\n\n    # Get the epic\n    epic = after.table(\"issues\").eq(\"id\", epic_id).first()\n    if not epic:\n        raise AssertionError(f\"Epic {epic_id} not found\")\n\n    epic_hours_ago = epic.get(\"hoursAgo\")\n    epic_duration = epic.get(\"duration\")\n\n    # Validate epic timing: starts in a week (-168 to -189) and lasts 14 days (312-336 hours)\n    if epic_hours_ago != -168:\n        raise AssertionError(f\"Expected epic hoursAgo to be -168, got {epic_hours_ago}\")\n\n    if epic_duration != 360:\n        raise AssertionError(\n            f\"Expected epic duration to be 360 hours, got {epic_duration}\"\n        )\n\n    # Get child issues of the epic (direct children, not nested subtasks)\n    child_issues = (\n        after.table(\"issues\").eq(\"epic_id\", epic_id).is_null(\"parent_id\").all()\n    )\n\n    if len(child_issues) != 5:\n        raise AssertionError(\n            f\"Expected 5 child issues for epic {epic_id}, found {len(child_issues)}\"\n        )\n\n    # Validate each child issue\n    issue_timings = []\n    for issue in child_issues:\n        issue_id = issue.get(\"id\")\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        # Each issue should start within the epic timeframe and last 2 days (47.9-72 hours)\n        if not (-456 <= hours_ago <= -168):\n            raise AssertionError(\n                f\"Expected issue {issue_id} hoursAgo between -456 and -168, got {hours_ago}\"\n            )\n\n        if duration != 72:\n            raise AssertionError(\n                f\"Expected issue {issue_id} duration to be 72 hours, got {duration}\"\n            )\n\n        issue_timings.append((issue_id, hours_ago, duration))\n\n    # Check for overlaps (no two issues should have overlapping time windows)\n    for i, (id1, start1, dur1) in enumerate(issue_timings):\n        end1 = start1 + dur1\n        for j, (id2, start2, dur2) in enumerate(issue_timings[i + 1 :], i + 1):\n            end2 = start2 + dur2\n            # Check if intervals overlap\n            if not (end1 <= start2 or end2 <= start1):\n                raise AssertionError(\n                    f\"Issues {id1} and {id2} have overlapping schedules: \"\n                    f\"{id1}({start1} to {end1}) overlaps with {id2}({start2} to {end2})\"\n                )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": epic_id,\n            \"field\": \"hoursAgo\",\n            \"after\": epic_hours_ago,\n        },\n        {\"table\": \"issues\", \"pk\": epic_id, \"field\": \"duration\", \"after\": epic_duration},\n    ]\n\n    for issue_id, hours_ago, duration in issue_timings:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": hours_ago,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"duration\",\n                    \"after\": duration,\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "start-ai-workflow-intelligence-project",
            "problem": "I'm looking to start the AI workflow intelligence project. Can you set the timeline of the advanced analytics epic, the AI pattern recognition epic, the conversational UI epic, and the core NLP infra epic to start today and end in 2w, then create a new sprint and move all issues under those epics to the new sprint?",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_start_ai_workflow_intelligence_project(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate AI workflow intelligence project timeline and sprint setup\"\"\"\n    # Expected epic IDs that should have hoursAgo = 0, duration = 336\n    epic_ids = [\"AIWORK-125\", \"AIWORK-181\", \"AIWORK-56\", \"AIWORK-1\"]\n\n    # Verify all epics have correct timing\n    for epic_id in epic_ids:\n        issue = after.table(\"issues\").eq(\"id\", epic_id).first()\n        if not issue:\n            raise AssertionError(f\"Epic {epic_id} not found\")\n\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        if hours_ago != 0:\n            raise AssertionError(\n                f\"Epic {epic_id} should have hoursAgo = 0, got {hours_ago}\"\n            )\n\n        if duration != 336:\n            raise AssertionError(\n                f\"Epic {epic_id} should have duration = 336, got {duration}\"\n            )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Find all tasks under these epics (with no parent_id)\n    epic_tasks = []\n    for epic_id in epic_ids:\n        tasks = after.table(\"issues\").eq(\"epic_id\", epic_id).is_null(\"parent_id\").all()\n        epic_tasks.extend([task[\"id\"] for task in tasks])\n\n    # Verify all epic tasks are in sprint_8\n    for task_id in epic_tasks:\n        after.table(\"sprint_issues\").eq(\"issue_id\", task_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic timing changes\n    for epic_id in epic_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": epic_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": 0,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": epic_id,\n                    \"field\": \"duration\",\n                    \"after\": 336,\n                },\n            ]\n        )\n\n    # Add sprint assignments for epic tasks\n    for task_id in epic_tasks:\n        # Find original sprint assignment\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", task_id).first()\n        )\n        if before_assignment:\n            old_sprint = before_assignment.get(\"sprint_id\")\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (old_sprint, task_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_8\", task_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "tag-medium-priority-debt",
            "problem": "Can you tag all issues in the active sprint for the tech debt project with \"Medium Priority\" if there's no current priority label? There should only be three.",
            "category": "label_and_priority_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_tag_medium_priority_debt(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-696, DEBT-741, and DEBT-540 have Medium Priority labels\"\"\"\n    issue_ids = [\"DEBT-696\", \"DEBT-741\", \"DEBT-540\"]\n\n    # Get Medium Priority label\n    medium_priority_label = after.table(\"labels\").eq(\"name\", \"Medium Priority\").first()\n    if not medium_priority_label:\n        raise AssertionError(\"Expected 'Medium Priority' label to exist\")\n\n    label_id = medium_priority_label[\"id\"]\n\n    # Verify all issues have the Medium Priority label\n    for issue_id in issue_ids:\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", label_id\n        ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - label assignments for all issues\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (issue_id, label_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Check if the label was newly created\n    before_label = before.table(\"labels\").eq(\"name\", \"Medium Priority\").first()\n    if not before_label:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": label_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reassign-active-security-tasks",
            "problem": "We just hired Olivia Chen as our new security engineer. Across all my projects, can you re-assign issues labeled \"Security\" in all active sprints to her? I suggest going through every single project and using the filters in the backlog page.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_reassign_active_security_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that Security labeled issues in active sprints are assigned to Olivia Chen\"\"\"\n    # Get Olivia Chen's user ID\n    olivia_user = after.table(\"users\").eq(\"name\", \"Olivia Chen\").first()\n    if not olivia_user:\n        raise AssertionError(\"User 'Olivia Chen' not found\")\n    olivia_id = olivia_user[\"id\"]\n\n    # Get Security label\n    security_label = after.table(\"labels\").eq(\"name\", \"Security\").first()\n    if not security_label:\n        raise AssertionError(\"Expected 'Security' label to exist\")\n    security_label_id = security_label[\"id\"]\n\n    # Find all Security labeled issues in active sprints\n    security_issues = (\n        after.table(\"issue_labels\")\n        .eq(\"label_id\", security_label_id)\n        .join(\"sprint_issues\", {\"issue_id\": \"issue_id\"})\n        .in_(\"sprint_id\", [\"sprint_1\", \"sprint_2\", \"sprint_5\"])\n        .all()\n    )\n\n    # Verify all these issues are assigned to Olivia Chen\n    for issue_assignment in security_issues:\n        issue_id = issue_assignment[\"issue_id\"]\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", olivia_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_assignment in security_issues:\n        issue_id = issue_assignment[\"issue_id\"]\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": olivia_id,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "vacation-reassign",
            "problem": "I am going on vacation for the next 7 days. If I have any issues (not epics or subtasks) in the tech debt or platform eng project issues that are set to end before I gets back from vacation, assign them to Thomas. To find these issues, you will go to the 'Timeline' view, open the epics, and scroll to the right to see all tasks projected to end between the blue line (today) and 7 days from now.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_vacation_reassign(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that immediate tasks due during vacation are assigned to Thomas Lee\"\"\"\n    # Get user IDs\n    sarah_kim_user = before.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    thomas_user = after.table(\"users\").eq(\"name\", \"Thomas Lee\").first()\n\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    if not thomas_user:\n        raise AssertionError(\"User 'Thomas Lee' not found\")\n\n    sarah_kim_id = sarah_kim_user[\"id\"]\n    thomas_id = thomas_user[\"id\"]\n\n    # Find all issues in DEBT project owned by Sarah Kim that are not Done, not Epic, not Subtask\n    all_issues = before.table(\"issues\").all()\n    sarah_debt_issues = []\n\n    for issue in all_issues:\n        # Check if it's in DEBT project (project_key starts with \"DEBT\")\n        if not issue.get(\"id\", \"\").startswith(\"DEBT-\") and not issue.get(\n            \"id\", \"\"\n        ).startswith(\"SCRUM-\"):\n            continue\n\n        # Check if owned by Sarah Kim\n        if issue.get(\"owner\") != sarah_kim_id:\n            continue\n\n        # Check if not Done\n        if issue.get(\"board_list\") == \"Done\":\n            continue\n\n        # Check if not Epic or Subtask\n        issue_type = issue.get(\"issue_type\", \"\")\n        if issue_type in [\"Epic\", \"Subtask\"]:\n            continue\n\n        sarah_debt_issues.append(issue)\n\n    # Filter for issues due during vacation: -60 < (hoursAgo - duration) <= 0\n    vacation_issues = []\n    for issue in sarah_debt_issues:\n        hours_ago = issue.get(\"hoursAgo\", 0)\n        duration = issue.get(\"duration\", 0)\n\n        if hours_ago is None or duration is None:\n            continue\n\n        time_until_due = hours_ago - duration\n\n        if -156 < time_until_due <= 0:\n            print(issue)\n            vacation_issues.append(issue)\n\n    # Verify all vacation issues are now assigned to Thomas Lee\n    vacation_issue_ids = [issue[\"id\"] for issue in vacation_issues]\n\n    for issue_id in vacation_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", thomas_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in vacation_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": thomas_id,\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reassign-onboarding-tools-to-raj",
            "problem": "The onboarding tools epic is going to be handled by Raj now. Can you change ownership of every issue sitting within the Develop Onboarding Tools epic to Raj? Also, go through the subtasks for each issue in this epic and assign those subtasks to Raj as well.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_reassign_onboarding_tools_to_raj(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1291 through 1319 are assigned to Raj Patel\"\"\"\n    issue_ids = [f\"SCRUM-{i}\" for i in range(1291, 1320)]  # 1291 through 1319\n\n    # Get Raj Patel's user ID\n    raj_patel_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_patel_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_patel_id = raj_patel_user[\"id\"]\n\n    # Check that all issues are assigned to Raj Patel\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_patel_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": raj_patel_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "plan-sprint-4-mobile",
            "problem": "I want you plan my next sprint (sprint 4) in platform engineering. I want the sprint to accomplish 1 objective: finish the mobile app. Find all mobile-related tasks in the backlog, assign Marcus to them, and move them to the new sprint. The easiest way to find all of these issues is by filtering by the 6 \"Mobile App v2.0\" epics and moving all related issues into the sprint.",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_plan_sprint_4_mobile(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Sprint 4 (id sprint_8) planning with mobile-focused task assignment for Marcus\"\"\"\n\n    # Define expected assignments for Marcus (mobile tasks)\n    marcus_issues = [\n        \"SCRUM-1257\",\n        \"SCRUM-1251\",\n        \"SCRUM-1245\",\n        \"SCRUM-1238\",\n        \"SCRUM-1231\",\n        \"SCRUM-1227\",\n        \"SCRUM-1224\",\n        \"SCRUM-1221\",\n        \"SCRUM-759\",\n        \"SCRUM-753\",\n        \"SCRUM-745\",\n        \"SCRUM-738\",\n        \"SCRUM-731\",\n    ]\n\n    # Get user ID for Marcus\n    marcus_johnson_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n\n    if not marcus_johnson_user:\n        raise AssertionError(\"User 'Marcus Johnson' not found\")\n\n    marcus_johnson_id = marcus_johnson_user[\"id\"]\n\n    # Check each issue is in sprint_8 and has correct owner\n    for issue_id in marcus_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", marcus_johnson_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Sprint creation (if not already existing)\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Issue owner assignments\n    for issue_id in marcus_issues:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": marcus_johnson_id,\n            }\n        )\n\n    # Sprint assignments\n    for issue_id in marcus_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_8\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"backlog\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reassign-by-capacity",
            "problem": "Can you reassign the 2 largest incomplete tasks by story points from the person with the highest workload to James Wilson in the tech debt project?",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_reassign_by_capacity(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that the 2 largest incomplete tasks are reassigned to James Wilson\"\"\"\n    issue_ids = [\"DEBT-554\", \"DEBT-576\"]\n\n    # Get James Wilson's user ID\n    james_wilson_user = after.table(\"users\").eq(\"name\", \"James Wilson\").first()\n    if not james_wilson_user:\n        raise AssertionError(\"User 'James Wilson' not found\")\n    james_wilson_id = james_wilson_user[\"id\"]\n\n    # Check that both issues are assigned to James Wilson\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", james_wilson_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": james_wilson_id,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "tag-completed-policies",
            "problem": "Can you tag the two security policy subtasks under my SOC 2 documentation package issue with the same labels as the parent task?",
            "category": "label_and_priority_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_tag_completed_policies(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-177 and DEBT-178 have Compliance and Documentation labels\"\"\"\n    issue_ids = [\"DEBT-177\", \"DEBT-178\"]\n\n    # Get required labels\n    compliance_label = after.table(\"labels\").eq(\"name\", \"Compliance\").first()\n    if not compliance_label:\n        raise AssertionError(\"Expected 'Compliance' label to exist\")\n\n    documentation_label = after.table(\"labels\").eq(\"name\", \"Documentation\").first()\n    if not documentation_label:\n        raise AssertionError(\"Expected 'Documentation' label to exist\")\n\n    compliance_id = compliance_label[\"id\"]\n    documentation_id = documentation_label[\"id\"]\n\n    # Verify both issues have both labels\n    for issue_id in issue_ids:\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", compliance_id\n        ).assert_exists()\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", documentation_id\n        ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - label assignments for both issues\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issue_labels\",\n                    \"pk\": (issue_id, compliance_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"issue_labels\",\n                    \"pk\": (issue_id, documentation_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    # Check if labels were newly created\n    before_compliance = before.table(\"labels\").eq(\"name\", \"Compliance\").first()\n    if not before_compliance:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": compliance_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before_documentation = before.table(\"labels\").eq(\"name\", \"Documentation\").first()\n    if not before_documentation:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": documentation_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-fedramp-project-with-sprint-and-tasks",
            "problem": "We're going to start making a push for FedRAMP authorization. Create a new project for this push, which should be named \"FedRAMP Certification\" and use the key FED. To create a project, use the \"+\" button near the \"Projects\" in the sidebar. Within this project, create a new sprint. Finally, we need to create a couple of tasks to framework this project. Create one task called Plan FedRAMP Certification and within this four child tasks: 1) Understand FedRAMP Requirements and Framework; 2) Determine our Authorization Path; 3) Conduct a Readiness Assessment; 4) Assemble Core Documentation and Teams. Start the sprint.",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_create_fedramp_project_with_sprint_and_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of FedRAMP Certification project with key FED, active sprint, and 5 tasks\"\"\"\n    # Check project exists with key \"FED\" and name \"FedRAMP Certification\"\n    after.table(\"projects\").eq(\"key\", \"FED\").assert_exists()\n    after.table(\"projects\").eq(\"key\", \"FED\").assert_eq(\"name\", \"FedRAMP Certification\")\n\n    # Check that sprint_8 exists and is active\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_eq(\"status\", \"active\")\n\n    # Check that 5 issues exist for FED project (FED-1 through FED-5)\n    fed_issues = [\"FED-1\", \"FED-2\", \"FED-3\", \"FED-4\", \"FED-5\"]\n    for issue_id in fed_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"project_key\", \"FED\")\n        # Verify all issues are in sprint_8\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).eq(\n            \"sprint_id\", \"sprint_8\"\n        ).assert_exists()\n\n    # Verify FED-2 through FED-5 have FED-1 as parent\n    for issue_id in [\"FED-2\", \"FED-3\", \"FED-4\", \"FED-5\"]:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"parent_id\", \"FED-1\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\"table\": \"projects\", \"pk\": \"FED\", \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    # Add issues and sprint assignments\n    for issue_id in fed_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_8\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-offline-capabilities-epic",
            "problem": "Within the platform engineering project, I want you to move ALL issues that discuss working on offline capabilities, offline tasks, offline data access, or any task related to \"offline\" into a new epic called \"Offline Capabilities\". I would suggest doing this in the \"Backlog\" view and search via keyword to find these tasks.",
            "category": "epic_management_and_organization",
            "difficulty": "hard",
            "verifier_func": "async def validate_create_offline_capabilities_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Offline Capabilities' epic SCRUM-1340 with specified issues moved under it\"\"\"\n    # Check that SCRUM-1340 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\n        \"name\", \"Offline Capabilities\"\n    )\n\n    # Define the offline capability issue IDs that should be under this epic\n    offline_issue_ids = [\n        \"SCRUM-1216\",\n        \"SCRUM-1211\",\n        \"SCRUM-1210\",\n        \"SCRUM-1205\",\n        \"SCRUM-1198\",\n        \"SCRUM-687\",\n        \"SCRUM-686\",\n        \"SCRUM-681\",\n        \"SCRUM-688\",\n        \"SCRUM-675\",\n        \"SCRUM-576\",\n        \"SCRUM-738\",\n        \"SCRUM-689\",\n    ]\n\n    # Check that all specified issues have epic_id set to SCRUM-1340\n    for issue_id in offline_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + all issue epic assignments\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    # Add epic_id changes for all offline capability issues\n    for issue_id in offline_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"SCRUM-1340\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reorganize-raj-debt-sprint",
            "problem": "I need you to re-organize my tech debt project's sprint 6. Specifically, Raj is going to be out of office so I need you to go into the Sprint 6 tasks, find all of Raj's tasks in Sprint 6, and then move them into Sprint 7. I like to move sprints using right click.",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_reorganize_raj_debt_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate reorganizing tech debt project sprint 6 by moving Raj's tickets to Sprint 7\"\"\"\n\n    # List of Raj's issues that should be moved to sprint_7\n    raj_issues = [\n        \"DEBT-169\",\n        \"DEBT-248\",\n        \"DEBT-280\",\n        \"DEBT-432\",\n        \"DEBT-703\",\n        \"DEBT-720\",\n        \"DEBT-765\",\n    ]\n\n    # Verify all issues are now in sprint_7\n    for issue_id in raj_issues:\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_7\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint reassignments - each issue moves from sprint_6 to sprint_7\n    for issue_id in raj_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_6\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_7\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "support-tickets-workflow-send-customer-messages",
            "problem": "There are a bunch of support tickets about our workflow execution history. They all related to one bug that's now fixed. Can you review each of them, and if our team has not responded to the users ticket or query, you must reply to the user letting them know this is being worked on. However, if one of our team has responded to the user and there are no outstanding questions from the user, don't reply again.",
            "category": "comments_and_communication",
            "difficulty": "hard",
            "verifier_func": "async def validate_support_tickets_workflow_send_customer_messages(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify appropriate comments are sent to customers for workflow history tickets\"\"\"\n    # Issues that should have new comments (excluding ones already replied to)\n    comment_issues_with_counts = {\n        \"SUP-410\": 5,\n        \"SUP-430\": 3,\n        \"SUP-450\": 3,\n        # \"SUP-473\": 3,\n        \"SUP-487\": 3,\n        \"SUP-496\": 3,\n    }\n\n    new_comment_ids = []\n\n    # Verify comment counts for issues that got new comments\n    for issue_id, expected_count in comment_issues_with_counts.items():\n        comment_count = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != expected_count:\n            raise AssertionError(\n                f\"Expected {expected_count} public comments on {issue_id}, found {comment_count}\"\n            )\n\n        # Verify exactly one new comment was added\n        before_count = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != before_count + 1:\n            raise AssertionError(\n                f\"Expected comment count to increase by 1 for {issue_id}. Before: {before_count}, After: {comment_count}\"\n            )\n\n        # Find the new comment\n        all_after_comments = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n        all_before_comments = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n\n        before_ids = {comment[\"id\"] for comment in all_before_comments}\n        new_comments = [\n            comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n        ]\n\n        if len(new_comments) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 new comment for {issue_id}, found {len(new_comments)}\"\n            )\n\n        new_comment_ids.append(new_comments[0][\"id\"])\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes for all new comments\n    expected_changes = []\n    for comment_id in new_comment_ids:\n        expected_changes.append(\n            {\n                \"table\": \"activities\",\n                \"pk\": comment_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "backend-priority",
            "problem": "Can you make sure every single issue in the platform engineering project currently in an active sprint with existing label \"Backend\" also has a priority-related label? If it doesn't, add the \"Medium Priority\" label. I recommend filtering by the label \"Backend\" to make your life easier. Also, don't accidentally delete labels with the \"x\" button when trying to adding new ones.",
            "category": "label_and_priority_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_backend_priority(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that backend tasks in engineering project have increased priority levels\"\"\"\n    # Get all backend issues that are not Epic or Subtask and are in sprint_1 or sprint_2\n    backend_label = after.table(\"labels\").eq(\"name\", \"Backend\").first()\n    if not backend_label:\n        raise AssertionError(\"Expected 'Backend' label to exist\")\n\n    # Get all issues with Backend label\n    backend_issue_labels = (\n        after.table(\"issue_labels\").eq(\"label_id\", backend_label[\"id\"]).all()\n    )\n    backend_issue_ids = [il[\"issue_id\"] for il in backend_issue_labels]\n\n    # Filter to only include issues that are in sprint_1 or sprint_2\n    sprint_filtered_issues = []\n    for issue_id in backend_issue_ids:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if sprint_assignment and sprint_assignment[\"sprint_id\"] in [\n            \"sprint_1\",\n            \"sprint_2\",\n        ]:\n            sprint_filtered_issues.append(issue_id)\n\n    # Filter to only include issues that are not Epic or Subtask\n    valid_backend_issues = []\n    for issue_id in sprint_filtered_issues:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if issue and issue[\"issue_type\"] not in [\"Epic\", \"Subtask\"]:\n            valid_backend_issues.append(issue_id)\n\n    if not valid_backend_issues:\n        raise AssertionError(\n            \"No valid backend issues found (non-Epic, non-Subtask, in sprint_1 or sprint_2)\"\n        )\n\n    # Get all priority labels (labels that contain \"Priority\")\n    all_labels = after.table(\"labels\").all()\n    priority_labels = [label for label in all_labels if \"Priority\" in label[\"name\"]]\n\n    if not priority_labels:\n        raise AssertionError(\"No priority labels found\")\n\n    priority_label_ids = [label[\"id\"] for label in priority_labels]\n\n    # Check that each valid backend issue has at least one priority label\n    for issue_id in valid_backend_issues:\n        issue_labels = after.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        issue_label_ids = [il[\"label_id\"] for il in issue_labels]\n\n        has_priority_label = any(\n            label_id in priority_label_ids for label_id in issue_label_ids\n        )\n        if not has_priority_label:\n            raise AssertionError(f\"Issue {issue_id} does not have a priority label\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check for newly created priority labels\n    before_labels = before.table(\"labels\").all()\n    before_label_names = {label[\"name\"] for label in before_labels}\n\n    for priority_label in priority_labels:\n        if priority_label[\"name\"] not in before_label_names:\n            expected_changes.append(\n                {\n                    \"table\": \"labels\",\n                    \"pk\": priority_label[\"id\"],\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    # Check for new issue-label assignments\n    for issue_id in valid_backend_issues:\n        after_issue_labels = after.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        before_issue_labels = (\n            before.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        )\n\n        after_label_ids = {il[\"label_id\"] for il in after_issue_labels}\n        before_label_ids = {il[\"label_id\"] for il in before_issue_labels}\n\n        new_label_ids = after_label_ids - before_label_ids\n\n        for label_id in new_label_ids:\n            # Only track priority label additions\n            if label_id in priority_label_ids:\n                expected_changes.append(\n                    {\n                        \"table\": \"issue_labels\",\n                        \"pk\": (issue_id, label_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    }\n                )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "organize-issues-under-compliance",
            "problem": "Create a new epic called \"Compliance\". Then, find all tasks in the technical debt project related to SOC II, GDPR, and HIPAA and assign each of them to the Compliance epic you created. To find all these tasks, I'd suggest you go into the backlog view, then filter by \"Epic\" (select the 3 relevant epics).",
            "category": "epic_management_and_organization",
            "difficulty": "hard",
            "verifier_func": "async def validate_organize_issues_under_compliance(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Compliance' epic DEBT-893 with SOC II, GDPR, and HIPAA issues organized under it\"\"\"\n\n    # Check that DEBT-893 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"name\", \"Compliance\")\n\n    # Define the compliance-related issue IDs that should be under this epic\n    compliance_issue_ids = [\n        \"DEBT-164\",\n        \"DEBT-185\",\n        \"DEBT-210\",\n        \"DEBT-222\",\n        \"DEBT-169\",\n        \"DEBT-172\",\n        \"DEBT-186\",\n        \"DEBT-214\",\n        \"DEBT-224\",\n        \"DEBT-176\",\n        \"DEBT-189\",\n        \"DEBT-219\",\n        \"DEBT-229\",\n        \"DEBT-179\",\n    ]\n\n    # Verify all compliance issues are now under the Compliance epic\n    for issue_id in compliance_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"DEBT-893\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + epic_id assignments for all compliance issues\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"DEBT-893\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic_id changes for all compliance issues\n    for issue_id in compliance_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"DEBT-893\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "assign-encryption-tasks-to-raj",
            "problem": "The ops team has prioritized SOC-II compliance, so we need to urgently finish all 5 data encryption and masking issues in the platform engineering project. Move all 5 data encryption and masking issues into sprint 1 and assign each of them to Raj. Ignore subtasks and epics, meaning I suggest you use the backlog page.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_assign_encryption_tasks_to_raj(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate encryption tasks moved to sprint 1 and assigned to Raj Patel\"\"\"\n    issue_ids = [\"SCRUM-1067\", \"SCRUM-1011\", \"SCRUM-1238\", \"SCRUM-1005\", \"SCRUM-738\"]\n\n    # Get Raj Patel's user ID\n    raj_patel_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_patel_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_patel_id = raj_patel_user[\"id\"]\n\n    # Check that all issues are assigned to Raj Patel and in sprint 1\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_patel_id)\n\n        # Check sprint assignment via sprint_issues table\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if not sprint_assignment or sprint_assignment.get(\"sprint_id\") != \"sprint_1\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in sprint_1, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id') if sprint_assignment else 'none'}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": raj_patel_id,\n            }\n        )\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_1\", issue_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n        # Also expect removal from previous sprint if they were assigned\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if before_assignment:\n            old_sprint = before_assignment.get(\"sprint_id\")\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (old_sprint, issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n    # Enforce invariant: only expected changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reassign-raj-subtasks-to-sarah",
            "problem": "I want you to go through a bunch of platform engineering issues, find 20 subtasks within those issues that are assigned to Raj that aren't marked \"Done\", and assign them to Sarah (not me). I'd suggest you use the backlog view and click through as it's easiest to work in bulk there.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_reassign_raj_subtasks_to_sarah(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that 20 of Raj's subtasks in active sprints are reassigned to Sarah\"\"\"\n\n    # Get user IDs\n    sarah_johnson_user = after.table(\"users\").eq(\"name\", \"Sarah Johnson\").first()\n    if not sarah_johnson_user:\n        raise AssertionError(\"User 'Sarah Johnson' not found\")\n    sarah_johnson_id = sarah_johnson_user[\"id\"]\n\n    raj_patel_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_patel_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_patel_id = raj_patel_user[\"id\"]\n\n    # Count Sarah's subtasks in active sprints (sprint_1 or sprint_2) with parent_id\n    sarah_subtasks = (\n        after.table(\"issues\")\n        .eq(\"owner\", sarah_johnson_id)\n        .not_null(\"parent_id\")\n        .join(\"sprint_issues\", {\"id\": \"issue_id\"})\n        .in_(\"sprint_id\", [\"sprint_1\", \"sprint_2\"])\n        .count()\n        .value\n    )\n\n    # Count Raj's remaining subtasks in active sprints\n    raj_subtasks = (\n        after.table(\"issues\")\n        .eq(\"owner\", raj_patel_id)\n        .not_null(\"parent_id\")\n        .join(\"sprint_issues\", {\"id\": \"issue_id\"})\n        .in_(\"sprint_id\", [\"sprint_1\", \"sprint_2\"])\n        .count()\n        .value\n    )\n\n    # Verify counts match expected distribution\n    if sarah_subtasks != 20:\n        raise AssertionError(\n            f\"Expected 20 subtasks assigned to Sarah Johnson, found {sarah_subtasks}\"\n        )\n    if raj_subtasks != 21:\n        raise AssertionError(\n            f\"Expected 21 subtasks remaining with Raj Patel, found {raj_subtasks}\"\n        )\n\n    # Get the specific subtasks that were reassigned to Sarah\n    sarah_subtask_list = (\n        after.table(\"issues\")\n        .eq(\"owner\", sarah_johnson_id)\n        .not_null(\"parent_id\")\n        .join(\"sprint_issues\", {\"id\": \"issue_id\"})\n        .in_(\"sprint_id\", [\"sprint_1\", \"sprint_2\"])\n        .all()\n    )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - only ownership changes for the 20 reassigned subtasks\n    expected_changes = []\n    for subtask in sarah_subtask_list:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": subtask[\"id\"],\n                \"field\": \"owner\",\n                \"after\": sarah_johnson_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specific subtasks\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "assign-raj-debt-to-me",
            "problem": "Raj Patel is a bit overloaded. Within the active sprint in the infrastructure project, first go through every issue assigned to Raj. Then, click into each one and assign any of his assigned subtasks that are 'To Do' to me. I'd suggest using the backlog view for this one.",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_assign_raj_debt_to_me(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Raj's To Do subtasks in infra project are reassigned to Sarah Kim\"\"\"\n\n    issue_ids = [\"DEBT-213\", \"DEBT-596\", \"DEBT-625\"]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify all issues are assigned to Sarah Kim\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": sarah_kim_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specified issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "assign-marcus-tasks-to-me",
            "problem": "I've noticed Marcus has way too much on his plate and is constantly context switching between tasks. Can you go to the backlog page in the tech debt project, open the next sprint up to view its issues, and assign all of Marcus' 'To Do' tasks to me (Sarah Kim)?",
            "category": "task_assignment_and_ownership",
            "difficulty": "hard",
            "verifier_func": "async def validate_assign_marcus_tasks_to_me(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Marcus's todo tasks in tech debt project are reassigned to Sarah Kim\"\"\"\n\n    issue_ids = [\n        \"DEBT-172\",\n        \"DEBT-214\",\n        \"DEBT-238\",\n        \"DEBT-332\",\n        \"DEBT-600\",\n        \"DEBT-627\",\n        \"DEBT-770\",\n    ]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify all issues are assigned to Sarah Kim\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": sarah_kim_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specified issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "plan-timeline-ai-workflow",
            "problem": "Can you plan my AI workflows project in the timeline view? You will have to scroll right many times until the blue line is on the left side of your screen. I want you to set the platform integration epic as starting today and lasting for one week \u2014 meaning the very left end of the purple bar should line up exactly with the blue line, and the right end lines up with the top counter indicating 7 days from today. You will have to scroll right in order to have everything in view. Then, expand the epic and for each of the issues under this epic, make each issue last for exactly 3 days and space them out roughly evenly across the epic. Make sure the end of any of the issues don't exceed either end of the epic's purple bar.",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_plan_timeline_ai_workflow(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify AI workflow timeline planning with epic and child issues\"\"\"\n    epic_id = \"AIWORK-151\"\n    child_issue_ids = [\n        \"AIWORK-152\",\n        \"AIWORK-159\",\n        \"AIWORK-166\",\n        \"AIWORK-171\",\n        \"AIWORK-177\",\n    ]\n\n    # Verify the epic exists and has correct timing\n    epic = after.table(\"issues\").eq(\"id\", epic_id).first()\n    if not epic:\n        raise AssertionError(f\"Epic {epic_id} not found\")\n\n    epic_hours_ago = epic.get(\"hoursAgo\")\n    epic_duration = epic.get(\"duration\")\n\n    # Epic should start today (144 hours ago) and last a week (168 hours)\n    if epic_hours_ago != 0:\n        raise AssertionError(\n            f\"Expected epic {epic_id} hoursAgo to be 0, got {epic_hours_ago}\"\n        )\n\n    if epic_duration != 168:\n        raise AssertionError(\n            f\"Expected epic {epic_id} duration to be 168 hours, got {epic_duration}\"\n        )\n\n    # Verify each child issue has correct timing\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": epic_id,\n            \"field\": \"hoursAgo\",\n            \"after\": 0,\n        },\n        {\n            \"table\": \"issues\",\n            \"pk\": epic_id,\n            \"field\": \"duration\",\n            \"after\": 168,\n        },\n    ]\n\n    for issue_id in child_issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Child issue {issue_id} not found\")\n\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        # Each child issue should last 3 days (72 hours)\n        if duration != 72:\n            raise AssertionError(\n                f\"Expected issue {issue_id} duration to be 72 hours, got {duration}\"\n            )\n\n        # Each child issue should start between 0 and -96 hours ago (spaced evenly)\n        if not (0 <= hours_ago <= -96):\n            raise AssertionError(\n                f\"Expected issue {issue_id} hoursAgo between 0 and -96, got {hours_ago}\"\n            )\n\n        # Add expected changes for this issue\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": hours_ago,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"duration\",\n                    \"after\": 72,\n                },\n            ]\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the timing fields changed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-bug-bash-sprint",
            "problem": "Can you create a new sprint called \"Bug Bash\" in platform engineering with a defined goal of finishing all bugs? Then, can you move all of my bugs with status \"To Do\" across all sprints to this new sprint? You can find this by filtering by type \"Bug\"; you'll have to expand all sprints active / not active / backlog to do this. Don't stop until you're done. You can right click to move issues between sprints.",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_create_bug_bash_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Bug Bash sprint creation and issue movement\"\"\"\n\n    # Find the Bug Bash sprint (should have ID > sprint_3)\n    bug_bash_sprint = after.table(\"sprints\").eq(\"name\", \"Bug Bash\").first()\n    if not bug_bash_sprint:\n        raise AssertionError(\"Bug Bash sprint was not created\")\n\n    sprint_id = bug_bash_sprint[\"id\"]\n\n    # Verify sprint has a meaningful goal\n    goal = bug_bash_sprint.get(\"goal\", \"\")\n    if not goal or len(goal.strip()) == 0:\n        raise AssertionError(\"Bug Bash sprint must have a goal set\")\n\n    # Verify specific issues are in the Bug Bash sprint\n    bug_issues = [\n        \"SCRUM-688\",\n        \"SCRUM-1331\",\n        \"SCRUM-956\",\n        \"SCRUM-897\",\n        \"SCRUM-882\",\n        \"SCRUM-822\",\n        \"SCRUM-790\",\n        \"SCRUM-781\",\n        \"SCRUM-780\",\n        \"SCRUM-555\",\n    ]\n\n    for issue_id in bug_issues:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if not sprint_assignment or sprint_assignment.get(\"sprint_id\") != sprint_id:\n            raise AssertionError(\n                f\"Issue {issue_id} should be in Bug Bash sprint {sprint_id}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\"table\": \"sprints\", \"pk\": sprint_id, \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add sprint assignments for all bug issues\n    for issue_id in bug_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (sprint_id, issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"backlog\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_3\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "move-support-questions-to-in-progress",
            "problem": "Can you move all support issues with work type \"Question\" (not feature requests or incidents) within the \"To Do\" status to the \"In Progress\" status, and assign them to Aisha? You can use the board view under \"Views\"; use the filter to filter by work type. Don't stop until you're done.",
            "category": "task_status_and_progress_updates",
            "difficulty": "hard",
            "verifier_func": "async def validate_move_support_questions_to_in_progress(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate support question issues moved to In Progress and assigned to Aisha Johnson\"\"\"\n    issue_ids = [\n        \"SUP-371\",\n        \"SUP-377\",\n        \"SUP-380\",\n        \"SUP-383\",\n        \"SUP-389\",\n        \"SUP-394\",\n        \"SUP-400\",\n        \"SUP-406\",\n        \"SUP-474\",\n        \"SUP-480\",\n        \"SUP-486\",\n        \"SUP-492\",\n        \"SUP-498\",\n        \"SUP-504\",\n        \"SUP-510\",\n        \"SUP-516\",\n    ]\n\n    # Get Aisha Johnson's user ID\n    aisha_user = after.table(\"users\").eq(\"name\", \"Aisha Johnson\").first()\n    if not aisha_user:\n        raise AssertionError(\"User 'Aisha Johnson' not found\")\n    aisha_id = aisha_user[\"id\"]\n\n    # Verify all issues are assigned to Aisha Johnson and in In Progress\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", aisha_id)\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"owner\",\n                    \"after\": aisha_id,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"board_list\",\n                    \"after\": \"In Progress\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "delete-error-issues",
            "problem": "We're a bit early to include error handling tasks in our AI workflows project. Can you go through all of my issues, subtasks, etc. and delete every single one with the word \"error\" in its name? Make sure you go through every single one to make sure they're properly deleted.",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_delete_error_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that AIWORK-72 has been deleted\"\"\"\n    issue_ids = [\n        \"AIWORK-72\",\n        \"AIWORK-73\",\n        \"AIWORK-74\",\n        \"AIWORK-43\",\n        \"AIWORK-44\",\n        \"AIWORK-45\",\n        \"AIWORK-31\",\n        \"AIWORK-165\",\n    ]\n\n    # Verify the issue no longer exists\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_none()\n\n    # Verify it existed before deletion\n    for issue_id in issue_ids:\n        before.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"issue_labels\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_watchers\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_voters\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - issue deletion and any related data\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": None,\n            \"after\": \"__removed__\",\n        }\n        for issue_id in issue_ids\n    ]\n\n    # Check if issue was in any sprint and add sprint removal if needed\n    for issue_id in issue_ids:\n        before_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if before_sprint_assignment:\n            sprint_id = before_sprint_assignment[\"sprint_id\"]\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (sprint_id, issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n    # Verify only expected deletions occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "delete-mobile-backlog-tasks",
            "problem": "We aligned and significantly scoped down mobile in my platform engineering project. I want you to delete all issues related to any of the mobile epics across all active sprints (sprints 1 and 2). To do this, I'd suggest going into the backlog view where you can filter by all epics with \"mobile\" in its name (there should be 6), then delete all issues that pop up in active sprints. Don't delete the epics, though.",
            "category": "other",
            "difficulty": "hard",
            "verifier_func": "async def validate_delete_mobile_backlog_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate deletion of mobile backlog tasks\"\"\"\n    deleted_issues = [\n        \"SCRUM-658\",\n        \"SCRUM-659\",\n        \"SCRUM-660\",\n        \"SCRUM-661\",\n        \"SCRUM-662\",\n        \"SCRUM-663\",\n        \"SCRUM-664\",\n        \"SCRUM-665\",\n        \"SCRUM-666\",\n        \"SCRUM-667\",\n        \"SCRUM-668\",\n        \"SCRUM-669\",\n        \"SCRUM-670\",\n        \"SCRUM-671\",\n        \"SCRUM-672\",\n        \"SCRUM-673\",\n        \"SCRUM-674\",\n        \"SCRUM-675\",\n        \"SCRUM-676\",\n        \"SCRUM-677\",\n        \"SCRUM-678\",\n        \"SCRUM-679\",\n        \"SCRUM-680\",\n        \"SCRUM-690\",\n        \"SCRUM-691\",\n        \"SCRUM-692\",\n        \"SCRUM-693\",\n        \"SCRUM-694\",\n        \"SCRUM-695\",\n        \"SCRUM-696\",\n        \"SCRUM-697\",\n        \"SCRUM-698\",\n        \"SCRUM-699\",\n        \"SCRUM-700\",\n        \"SCRUM-701\",\n        \"SCRUM-702\",\n        \"SCRUM-703\",\n        \"SCRUM-704\",\n        \"SCRUM-705\",\n        \"SCRUM-706\",\n        \"SCRUM-707\",\n        \"SCRUM-708\",\n        \"SCRUM-709\",\n        \"SCRUM-710\",\n        \"SCRUM-711\",\n        \"SCRUM-712\",\n        \"SCRUM-713\",\n        \"SCRUM-714\",\n        \"SCRUM-715\",\n        \"SCRUM-716\",\n        \"SCRUM-717\",\n        \"SCRUM-718\",\n        \"SCRUM-719\",\n        \"SCRUM-720\",\n        \"SCRUM-721\",\n        \"SCRUM-722\",\n        \"SCRUM-723\",\n        \"SCRUM-724\",\n        \"SCRUM-725\",\n        \"SCRUM-726\",\n        \"SCRUM-727\",\n        \"SCRUM-728\",\n        \"SCRUM-729\",\n        \"SCRUM-730\",\n        \"SCRUM-1198\",\n        \"SCRUM-1199\",\n        \"SCRUM-1200\",\n        \"SCRUM-1201\",\n        \"SCRUM-1202\",\n        \"SCRUM-1203\",\n        \"SCRUM-1204\",\n        \"SCRUM-1205\",\n        \"SCRUM-1206\",\n        \"SCRUM-1207\",\n        \"SCRUM-1208\",\n        \"SCRUM-1209\",\n        \"SCRUM-1210\",\n        \"SCRUM-1211\",\n        \"SCRUM-1212\",\n        \"SCRUM-1213\",\n        \"SCRUM-1214\",\n        \"SCRUM-1215\",\n        \"SCRUM-1216\",\n        \"SCRUM-1217\",\n        \"SCRUM-1218\",\n        \"SCRUM-1219\",\n        \"SCRUM-1220\",\n        \"SCRUM-1230\",\n    ]\n\n    # Verify all specified issues are deleted\n    for issue_id in deleted_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_none()\n        # Verify they existed before\n        before.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"issue_labels\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_watchers\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_voters\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list - all deletions\n    expected_changes = []\n    for issue_id in deleted_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                # Sprint assignments would also be deleted due to CASCADE\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"backlog\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n            ]\n        )\n\n    # Verify only expected deletions occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-cs-project-and-first-tasks",
            "problem": "Can you create a new project for my Customer Success (CS) team with key \"CS\" and create 4 issues in backlog \u2014 1 to establish a CS playbook, 1 to set up 1x1 conversations with all enterprise accounts, 1 to sync with the VP of sales, and 1 to speak with DevOps about the workflow issues?",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_create_cs_project_and_first_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that the CS project and tasks are created\"\"\"\n    # Get all CS issues\n    cs_issues = after.table(\"issues\").eq(\"project_key\", \"CS\").all()\n    if len(cs_issues) != 4:\n        raise AssertionError(f\"Expected 4 CS issues, found {len(cs_issues)}\")\n\n    # Verify all issues are in backlog sprint via sprint_issues join table\n    for issue in cs_issues:\n        issue_id = issue.get(\"id\")\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if not sprint_assignment:\n            raise AssertionError(f\"Issue {issue_id} is not assigned to any sprint\")\n\n        if sprint_assignment.get(\"sprint_id\") != \"backlog\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in backlog sprint, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id')}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\"table\": \"projects\", \"pk\": \"CS\", \"field\": None, \"after\": \"__added__\"},\n            {\"table\": \"issues\", \"pk\": \"CS-1\", \"field\": None, \"after\": \"__added__\"},\n            {\"table\": \"issues\", \"pk\": \"CS-2\", \"field\": None, \"after\": \"__added__\"},\n            {\"table\": \"issues\", \"pk\": \"CS-3\", \"field\": None, \"after\": \"__added__\"},\n            {\"table\": \"issues\", \"pk\": \"CS-4\", \"field\": None, \"after\": \"__added__\"},\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"backlog\", \"CS-1\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"backlog\", \"CS-2\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"backlog\", \"CS-3\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"backlog\", \"CS-4\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "new-ai-workflow-sprint-from-epics",
            "problem": "I need your help planning a new sprint 1 in the AI workflow project. First, create the sprint. Then, move the first task (ordered by the number in the ticket ID) from each epic in this project into the sprint you just created. There should be 10 tasks in the sprint at the end of this ",
            "category": "project_and_sprint_management",
            "difficulty": "hard",
            "verifier_func": "async def validate_new_ai_workflow_sprint_from_epics(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n):\n    \"\"\"Verify AI workflow issues are moved to sprint_8\"\"\"\n    print(\"validate_ai_workflow_sprint_from_epics\")\n    # Get all AIWORK issues that should be in sprint_8\n    expected_issues = [\n        \"AIWORK-2\",\n        \"AIWORK-26\",\n        \"AIWORK-57\",\n        \"AIWORK-77\",\n        \"AIWORK-101\",\n        \"AIWORK-126\",\n        \"AIWORK-152\",\n        \"AIWORK-182\",\n        \"AIWORK-209\",\n        \"AIWORK-244\",\n    ]\n\n    # Verify each issue is assigned to sprint_8\n    for issue_id in expected_issues:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        # Check sprint assignment via sprint_issues join table\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if not sprint_assignment:\n            raise AssertionError(f\"Issue {issue_id} is not assigned to any sprint\")\n\n        if sprint_assignment.get(\"sprint_id\") != \"sprint_8\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in sprint_8, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id')}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected changes occurred (sprint assignments to sprint_8)\n    expected_changes = []\n    for issue_id in expected_issues:\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_8\", issue_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "unify-k8s-issues",
            "problem": "Can you unify all my issues of type \"story\" or \"task\" in the tech debt project with 'Kubernetes' in the name under one single new epic called \"Kubernetes\"?",
            "category": "epic_management_and_organization",
            "difficulty": "medium",
            "verifier_func": "async def validate_unify_k8s_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Kubernetes' epic DEBT-893 with k8s issues unified under it\"\"\"\n\n    # Check that DEBT-893 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"name\", \"Kubernetes\")\n\n    # Define the k8s issue IDs that should be under this epic\n    k8s_issue_ids = [\"DEBT-418\", \"DEBT-597\"]\n\n    # Verify all k8s issues are now under the Kubernetes epic\n    for issue_id in k8s_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"DEBT-893\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + epic_id assignments for k8s issues\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"DEBT-893\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic_id changes for k8s issues\n    for issue_id in k8s_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"DEBT-893\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "tag-parallel-workflows-backend",
            "problem": "Go to the implement parallel workflows in ai workflow builder issue from the platform engineering project and make sure it's tagged as a Backend task.",
            "category": "label_and_priority_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_tag_parallel_workflows_backend(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-552 has Feature, Enhancement, High Priority, and Backend labels\"\"\"\n    # Check that required labels exist\n    feature_label = after.table(\"labels\").eq(\"name\", \"Feature\").first()\n    enhancement_label = after.table(\"labels\").eq(\"name\", \"Enhancement\").first()\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    backend_label = after.table(\"labels\").eq(\"name\", \"Backend\").first()\n\n    if not feature_label:\n        raise AssertionError(\"Expected 'Feature' label to exist\")\n    if not enhancement_label:\n        raise AssertionError(\"Expected 'Enhancement' label to exist\")\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n    if not backend_label:\n        raise AssertionError(\"Expected 'Backend' label to exist\")\n\n    feature_id = feature_label[\"id\"]\n    enhancement_id = enhancement_label[\"id\"]\n    high_priority_id = high_priority_label[\"id\"]\n    backend_id = backend_label[\"id\"]\n\n    # Verify SCRUM-552 has exactly these four labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", feature_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", enhancement_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", backend_id\n    ).assert_exists()\n\n    # Verify SCRUM-552 has exactly 4 labels\n    scrum_552_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").count().value\n    )\n    if scrum_552_labels != 4:\n        raise AssertionError(\n            f\"Expected SCRUM-552 to have exactly 4 labels, found {scrum_552_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_feature = before.table(\"labels\").eq(\"name\", \"Feature\").first()\n    before_enhancement = before.table(\"labels\").eq(\"name\", \"Enhancement\").first()\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    before_backend = before.table(\"labels\").eq(\"name\", \"Backend\").first()\n\n    if not before_feature:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": feature_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_enhancement:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": enhancement_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_backend:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": backend_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    # Get all labels SCRUM-552 had before and remove them\n    before_scrum_552_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").all()\n    )\n    for old_assignment in before_scrum_552_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", feature_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", enhancement_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", backend_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "set-unlabeled-timeline-typescript-migration",
            "problem": "Under the typescript migration epic in the tech debt project, there are a few issues that aren't yet planned on the timeline. Can you plan them to be within the boundaries of the epic's timeline (meaning leftmost side of the epic's purple bar lines up or is to the left of every one of its children's; rightmost side of the epic's purple bar lines up on or to the left of every one if its children.? You will have to scroll right until the rightmost edge of the purple bar for the typescript migration comes into view.",
            "category": "other",
            "difficulty": "medium",
            "verifier_func": "async def validate_set_unlabeled_timeline_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that unlabeled TypeScript migration issues are planned within epic boundaries\"\"\"\n    # Get the epic's timeline\n    epic = after.table(\"issues\").eq(\"id\", \"DEBT-793\").first()\n    if not epic:\n        raise AssertionError(\"Epic DEBT-793 not found\")\n\n    epic_hours_ago = epic.get(\"hoursAgo\")\n    epic_duration = epic.get(\"duration\")\n    epic_start = epic_hours_ago\n    epic_end = epic_hours_ago - epic_duration\n\n    # Issues that should be planned within epic boundaries\n    issue_ids = [\n        \"DEBT-794\",\n        \"DEBT-799\",\n        \"DEBT-805\",\n        \"DEBT-809\",\n        \"DEBT-814\",\n        \"DEBT-818\",\n        \"DEBT-821\",\n    ]\n\n    # Verify each issue has timing within epic boundaries and is not null\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        if hours_ago is None or duration is None:\n            raise AssertionError(\n                f\"Issue {issue_id} should have hoursAgo and duration set\"\n            )\n\n        issue_start = hours_ago\n        issue_end = hours_ago - duration\n\n        # Check if issue is within epic boundaries\n        if issue_start > epic_start or issue_end < epic_end:\n            raise AssertionError(\n                f\"Issue {issue_id} (start: {issue_start}, end: {issue_end}) \"\n                f\"is not within epic boundaries (start: {epic_start}, end: {epic_end})\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": issue.get(\"hoursAgo\"),\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"duration\",\n                    \"after\": issue.get(\"duration\"),\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "assign-salesforce-connector-to-self",
            "problem": "I want to pick up and work on the salesforce data connector task. I want you to navigate to this task, assign it to me, and move it into Sprint 2.",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_assign_salesforce_connector_to_self(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate SCRUM-948 assigned to Sarah Kim and moved to sprint 2\"\"\"\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check assignment and sprint\n    after.table(\"issues\").eq(\"id\", \"SCRUM-948\").assert_eq(\"owner\", sarah_kim_id)\n\n    # Check sprint assignment via sprint_issues table\n    sprint_assignment = after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-948\").first()\n    if not sprint_assignment or sprint_assignment.get(\"sprint_id\") != \"sprint_2\":\n        raise AssertionError(\n            f\"Issue SCRUM-948 should be in sprint_2, \"\n            f\"but is in sprint {sprint_assignment.get('sprint_id') if sprint_assignment else 'none'}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-948\",\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_2\", \"SCRUM-948\"),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Also expect removal from previous sprint if it was assigned\n    before_assignment = (\n        before.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-948\").first()\n    )\n    if before_assignment:\n        old_sprint = before_assignment.get(\"sprint_id\")\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (old_sprint, \"SCRUM-948\"),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "backlog-task-priority",
            "problem": "I think the value of the highest story point task in the AI workflow intel project is overstated. Change story point of the highest story point issue to be one greater than the next highest issue.",
            "category": "label_and_priority_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_backlog_task_priority(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-159 has story_points set to 35\"\"\"\n    issue_id = \"AIWORK-159\"\n\n    # Verify the issue has 35 story points\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"story_points\", 35)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected change - story points update\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"story_points\",\n            \"after\": 35,\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-three-bugs",
            "problem": "Can you create three bugs - one called \"Workflow builder UI flicker\", one called \"Search fails to pop up sometimes\", one called \"Onboarding sometimes stuck on step 3\" with the first two in sprint 1, the last in sprint 2; make all in progress and assign to me in platform eng",
            "category": "task_creation_and_subtask_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_create_three_bugs(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of three specific bugs with correct assignments and sprints\"\"\"\n    # Check bug 1: \"Workflow builder UI flicker\" in sprint_1, assigned to Sarah Kim\n    bug1 = after.table(\"issues\").ilike(\"name\", \"%Workflow builder UI flicker%\").first()\n    if not bug1:\n        raise AssertionError(\"Bug 'Workflow builder UI flicker' not found\")\n\n    # Check sprint assignment via sprint_issues table\n    sprint1_assignment = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug1[\"id\"])\n        .eq(\"sprint_id\", \"sprint_1\")\n        .first()\n    )\n    if not sprint1_assignment:\n        raise AssertionError(f\"Bug {bug1['id']} should be in sprint_1\")\n\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check owner\n    if bug1[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug1['id']} should be assigned to Sarah Kim, got {bug1['owner']}\"\n        )\n\n    # Check bug 2: \"Search fails to pop up sometimes\" in sprint_1, assigned to Sarah Kim\n    bug2 = (\n        after.table(\"issues\")\n        .ilike(\"name\", \"%Search fails to pop up sometimes%\")\n        .first()\n    )\n    if not bug2:\n        raise AssertionError(\"Bug 'Search fails to pop up sometimes' not found\")\n\n    sprint1_assignment2 = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug2[\"id\"])\n        .eq(\"sprint_id\", \"sprint_1\")\n        .first()\n    )\n    if not sprint1_assignment2:\n        raise AssertionError(f\"Bug {bug2['id']} should be in sprint_1\")\n\n    if bug2[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug2['id']} should be assigned to Sarah Kim, got {bug2['owner']}\"\n        )\n\n    # Check bug 3: \"Onboarding sometimes stuck on step 3\" in sprint_2, assigned to Sarah Kim\n    bug3 = (\n        after.table(\"issues\")\n        .ilike(\"name\", \"%Onboarding sometimes stuck on step 3%\")\n        .first()\n    )\n    if not bug3:\n        raise AssertionError(\"Bug 'Onboarding sometimes stuck on step 3' not found\")\n\n    sprint2_assignment = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug3[\"id\"])\n        .eq(\"sprint_id\", \"sprint_2\")\n        .first()\n    )\n    if not sprint2_assignment:\n        raise AssertionError(f\"Bug {bug3['id']} should be in sprint_2\")\n\n    if bug3[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug3['id']} should be assigned to Sarah Kim, got {bug3['owner']}\"\n        )\n\n    # Check all are bug type and in progress\n    for bug in [bug1, bug2, bug3]:\n        if bug[\"issue_type\"] != \"Bug\":\n            raise AssertionError(\n                f\"Issue {bug['id']} should be of type Bug, got {bug['issue_type']}\"\n            )\n        if bug[\"board_list\"] != \"In Progress\":\n            raise AssertionError(\n                f\"Bug {bug['id']} should be In Progress, got {bug['board_list']}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": bug1[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"issues\", \"pk\": bug2[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"issues\", \"pk\": bug3[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", bug1[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", bug2[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_2\", bug3[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "move-high-priority-to-in-progress",
            "problem": "Can you move all highest and high priority support from \"To Do\" to \"In progress\" and assign them to me?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_move_high_priority_to_in_progress(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate highest and high priority support issues moved to In Progress and assigned to Sarah Kim\"\"\"\n    issue_id = \"SUP-368\"\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify issue is assigned to Sarah Kim and in In Progress\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        },\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"board_list\",\n            \"after\": \"In Progress\",\n        },\n    ]\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "delete-error-recovery-issue",
            "problem": "We're a bit early to include error recovery tasks in our AI workflows project. If you find any error recovery issues in our AI workflows project, can you delete them? Specifically, only delete tasks with \"error\" and \"recovery\" both in its name.",
            "category": "other",
            "difficulty": "medium",
            "verifier_func": "async def validate_delete_error_recovery_issue(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that AIWORK-72 has been deleted\"\"\"\n    issue_ids = [\n        \"AIWORK-72\",\n        \"AIWORK-73\",\n        \"AIWORK-74\",\n        \"AIWORK-43\",\n        \"AIWORK-44\",\n        \"AIWORK-45\",\n    ]\n\n    # Verify the issue no longer exists\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_none()\n\n    # Verify it existed before deletion\n    for issue_id in issue_ids:\n        before.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"issue_labels\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_watchers\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_voters\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - issue deletion and any related data\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": None,\n            \"after\": \"__removed__\",\n        }\n        for issue_id in issue_ids\n    ]\n\n    # Check if issue was in any sprint and add sprint removal if needed\n    for issue_id in issue_ids:\n        before_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if before_sprint_assignment:\n            sprint_id = before_sprint_assignment[\"sprint_id\"]\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (sprint_id, issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n    # Verify only expected deletions occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "elastic-search-implementation",
            "problem": "It looks like we're already creating an Elasticsearch cluster for some internal use cases. Can you link and set one of my Elasticsearch issues as implemented by the other? Specifically, the subtasks - not the parent tasks.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_elastic_search_implementation(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-206 is implemented by DEBT-292\"\"\"\n    # Check that AIWORK-206 is implemented by DEBT-292\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"AIWORK-206\")\n        .eq(\"target_issue_id\", \"DEBT-292\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected AIWORK-206 to be implemented by DEBT-292\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "reconcile-image-loading-labels",
            "problem": "Can you go in to the improve image loading and caching ticket and check the description? Once you find the priority described within the description, make sure the task has the label \"_ Priority\" (ie \"Low Priority\") in accordance with the description.",
            "category": "label_and_priority_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_reconcile_image_loading_labels(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-711 has Frontend, Performance, and High Priority labels\"\"\"\n    # Check that required labels exist\n    frontend_label = after.table(\"labels\").eq(\"name\", \"Frontend\").first()\n    performance_label = after.table(\"labels\").eq(\"name\", \"Performance\").first()\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n\n    if not frontend_label:\n        raise AssertionError(\"Expected 'Frontend' label to exist\")\n    if not performance_label:\n        raise AssertionError(\"Expected 'Performance' label to exist\")\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n\n    frontend_id = frontend_label[\"id\"]\n    performance_id = performance_label[\"id\"]\n    high_priority_id = high_priority_label[\"id\"]\n\n    # Verify SCRUM-711 has exactly these three labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", frontend_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", performance_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n\n    # Verify SCRUM-711 has exactly 3 labels\n    scrum_711_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").count().value\n    )\n    if scrum_711_labels != 3:\n        raise AssertionError(\n            f\"Expected SCRUM-711 to have exactly 3 labels, found {scrum_711_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_frontend = before.table(\"labels\").eq(\"name\", \"Frontend\").first()\n    before_performance = before.table(\"labels\").eq(\"name\", \"Performance\").first()\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n\n    if not before_frontend:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": frontend_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_performance:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": performance_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Get all labels SCRUM-711 had before and remove them\n    before_scrum_711_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").all()\n    )\n    for old_assignment in before_scrum_711_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", frontend_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", performance_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "bcrypt-is-the-bingo",
            "problem": "We're on cleanup duty today. Find the user authentication module refactoring ticket, and make sure to create a sub-task to test whether the tech Marcus thinks is the best solution actually works for our use-case. Make sure you include the name of this tech in the new issue's name",
            "category": "task_creation_and_subtask_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_bcrypt_is_the_bingo(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1340 is created and its name includes 'bcrypt'\"\"\"\n    # Check that SCRUM-1340 exists\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n\n    # Get the issue and verify name includes \"bcrypt\"\n    issue = after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").first()\n    if not issue:\n        raise AssertionError(\"Issue SCRUM-1340 not found\")\n\n    issue_name = issue.get(\"name\", \"\").lower()\n    if \"bcrypt\" not in issue_name:\n        raise AssertionError(\n            f\"Expected SCRUM-1340 name to include 'bcrypt', got '{issue['name']}'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the new issue was added\n    before.diff(after, ignore_config).expect_only(\n        [{\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"}]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "raj-comment-to-task",
            "problem": "Can you turn Raj's last comment in the workflow optimization recommendation system task into a new task in the same project? You can assign it to Raj Patel. Add the comment verbatim into the description.",
            "category": "task_creation_and_subtask_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_raj_comment_to_task(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of new task from Raj's comment\"\"\"\n    # Find the new task AIWORK-288\n    new_task = after.table(\"issues\").eq(\"id\", \"AIWORK-288\").first()\n\n    if not new_task:\n        raise AssertionError(\"Expected new task to be AIWORK-288\")\n\n    # Get Raj Patel's user ID\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_id = raj_user[\"id\"]\n\n    # Verify task is assigned to Raj Patel\n    if new_task[\"owner\"] != raj_id:\n        raise AssertionError(\n            f\"Expected new task to be assigned to Raj Patel, got {new_task['owner']}\"\n        )\n\n    # Verify project_key is AIWORK\n    if new_task[\"project_key\"] != \"AIWORK\":\n        raise AssertionError(\n            f\"Expected new task to have project_key 'AIWORK', got {new_task['project_key']}\"\n        )\n\n    # Verify description includes the expected text\n    expected_description_text = \"Yes, that's a key use case. We'll compare customer workflows against our template library and successful peer implementations to identify replacement opportunities.\"\n    if expected_description_text not in new_task.get(\"description\", \"\"):\n        raise AssertionError(\n            f\"Expected task description to include '{expected_description_text}', got '{new_task.get('description', '')}'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": new_task[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "blocked-by-cicd-tasks",
            "problem": "Can you set my task for CI/CD pipeline optimization with spot instances to being blocked by my CI/CD pipeline optimization epic? They're in separate projects.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_blocked_by_cicd_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-667 is blocked by SCRUM-523\"\"\"\n    # Check that DEBT-667 is blocked by SCRUM-523\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-523\")\n        .eq(\"target_issue_id\", \"DEBT-667\")\n        .eq(\"relationship_type\", \"blocks\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected DEBT-667 to be blocked by SCRUM-523\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "offline-mode-took-a-step-backwards",
            "problem": "The team working on the mobile app v2.0 offline capabilities epic didn't scope the task correctly. I need you to move of its child issues and their associated subtasks from done / in review to in progress. Go through every single issue and its subtasks, as even though an issue can be ex. \"In Progress\", its children can still be 'Done'. Remember, you can change the status of an issue or subtask directly in the 'Child work items' view.",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_offline_mode_took_a_step_backwards(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate offline mode tasks moved to In Progress\"\"\"\n    # Issue IDs that should be moved to In Progress\n    issue_ids = [\n        \"SCRUM-1205\",\n        \"SCRUM-1210\",\n        \"SCRUM-1215\",\n        \"SCRUM-1216\",\n        \"SCRUM-1217\",\n        \"SCRUM-1218\",\n        \"SCRUM-1206\",\n        \"SCRUM-1207\",\n        \"SCRUM-1214\",\n        \"SCRUM-1219\",\n        \"SCRUM-1220\",\n    ]\n\n    # Verify all issues are moved to In Progress\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"In Progress\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "plan-future-sprint-soc-2-zero-trust",
            "problem": "I need your help planning a new sprint 8 in my tech debt project. First, create the sprint. Then, move the last SOC-2 type II issue (assign it to Maya) and the zero-trust issues (assign it to Sarah Johnson) to the new sprint.",
            "category": "project_and_sprint_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_plan_future_sprint_soc_2_zero_trust(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning new sprint 8 in tech debt project with SOC 2 and Zero Trust assignments\"\"\"\n\n    # Define issue assignments for SOC 2 and Zero Trust\n    maya_issues = [\"DEBT-179\"]\n    sarah_johnson_issues = [\"DEBT-203\"]\n\n    all_sprint_8_issues = maya_issues + sarah_johnson_issues\n\n    # Get user IDs for the assignees\n    maya_user = after.table(\"users\").eq(\"name\", \"Maya Williams\").first()\n    sarah_johnson_user = after.table(\"users\").eq(\"name\", \"Sarah Johnson\").first()\n\n    if not maya_user:\n        raise AssertionError(\"User 'Maya Williams' not found\")\n    if not sarah_johnson_user:\n        raise AssertionError(\"User 'Sarah Johnson' not found\")\n\n    maya_id = maya_user[\"id\"]\n    sarah_johnson_id = sarah_johnson_user[\"id\"]\n\n    # Check each issue is in sprint_8 and has correct owner\n    for issue_id in maya_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", maya_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    for issue_id in sarah_johnson_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_johnson_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint creation\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Issue owner assignments\n    for issue_id in maya_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": maya_id}\n        )\n    for issue_id in sarah_johnson_issues:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": sarah_johnson_id,\n            }\n        )\n\n    # Sprint assignments\n    for issue_id in all_sprint_8_issues:\n        # Find the original sprint for this issue\n        original_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if original_sprint_assignment:\n            original_sprint_id = original_sprint_assignment[\"sprint_id\"]\n            expected_changes.extend(\n                [\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (original_sprint_id, issue_id),\n                        \"field\": None,\n                        \"after\": \"__removed__\",\n                    },\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (\"sprint_8\", issue_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    },\n                ]\n            )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "create-onboarding-wizard-epic",
            "problem": "Create a new epic called \"Onboarding Wizard.\" Then, find all issues related to \"onboarding wizard\" and assign all of these tasks to this new epic. Don't do this for all issues related to onboarding; only issues that have \"onboarding wizard\" in the title.",
            "category": "epic_management_and_organization",
            "difficulty": "medium",
            "verifier_func": "async def validate_create_onboarding_wizard_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Onboarding Wizard' epic SCRUM-1340 with specified tasks as children\"\"\"\n    # Check that SCRUM-1340 exists as an Epic\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"name\", \"Onboarding Wizard\")\n\n    # Define the onboarding wizard task IDs that should be under this epic\n    task_ids = [\"SCRUM-831\", \"SCRUM-835\", \"SCRUM-843\"]\n\n    # Check that all specified tasks have epic_id set to SCRUM-1340\n    for task_id in task_ids:\n        after.table(\"issues\").eq(\"id\", task_id).assert_eq(\"epic_id\", \"SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + all task parent assignments\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    # Add epic_id changes for all tasks\n    for task_id in task_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": task_id,\n                \"field\": \"epic_id\",\n                \"after\": \"SCRUM-1340\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "set-predictive-insights-blocks",
            "problem": "Can you set my \"implement predictive insights feature\" issue to blocked by testing this insights feature? Also, set the ticket implementing the predictive insights API to blocked by documenting the predictive insights. Do this using the \"Add\" linked item feature. All these issues are in the platform engineering project.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_set_predictive_insights_blocks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-876 is blocked by SCRUM-860 and SCRUM-847 is blocked by SCRUM-864\"\"\"\n    # Check that SCRUM-876 is blocked by SCRUM-860\n    relationship_876 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-860\")\n        .eq(\"target_issue_id\", \"SCRUM-876\")\n        .eq(\"relationship_type\", \"blocks\")\n        .first()\n    )\n\n    if not relationship_876:\n        raise AssertionError(\"Expected SCRUM-876 to be blocked by SCRUM-860\")\n\n    # Check that SCRUM-847 is blocked by SCRUM-864\n    relationship_847 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-864\")\n        .eq(\"target_issue_id\", \"SCRUM-847\")\n        .eq(\"relationship_type\", \"blocks\")\n        .first()\n    )\n\n    if not relationship_847:\n        raise AssertionError(\"Expected SCRUM-847 to be blocked by SCRUM-864\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected relationships were added\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship_876[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship_847[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "enhancement-task-to-in-review",
            "problem": "Can you move all tasks labeled enhancement in the product eng project to from todo / in progress to in review in active sprints only?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_enhancement_task_to_in_review(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that enhancement tasks in engineering project are moved to In Review in active sprints\"\"\"\n    expected_issue_ids = [\"SCRUM-552\", \"SCRUM-1076\", \"SCRUM-1061\", \"SCRUM-1072\"]\n\n    # Verify all issues are marked as \"In Review\"\n    for issue_id in expected_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Review\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in expected_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"In Review\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-task-and-subtasks",
            "problem": "Create a new task to build a data pipe for consensus data in platform eng, which will contain 3 subtasks: one to negotiate with S&P, one to build the connector, and one to test. Set the main task as blocked by the data processing pipeline refactor ticket.",
            "category": "task_creation_and_subtask_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_create_task_and_subtasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of data pipe consensus task with 3 subtasks and blocked relationship\"\"\"\n    # Find the main task (should be related to data pipe/consensus with ID > SCRUM-1339)\n    all_issues = after.table(\"issues\").all()\n\n    # Filter for new issues (ID > SCRUM-1339) that are not subtasks\n    main_task_candidates = []\n    for issue in all_issues:\n        issue_id = issue[\"id\"]\n        if issue_id.startswith(\"SCRUM-\"):\n            try:\n                issue_num = int(issue_id.split(\"-\")[1])\n                if issue_num > 1339 and issue.get(\"issue_type\") != \"Subtask\":\n                    main_task_candidates.append(issue)\n            except (ValueError, IndexError):\n                continue\n\n    if not main_task_candidates:\n        raise AssertionError(\n            \"Could not find main data pipe consensus task with ID > SCRUM-1339\"\n        )\n\n    main_task = main_task_candidates[0]\n    main_task_id = main_task[\"id\"]\n\n    # Check that 3 subtasks exist for this main task\n    subtasks = after.table(\"issues\").eq(\"parent_id\", main_task_id).all()\n    if len(subtasks) != 3:\n        raise AssertionError(\n            f\"Expected 3 subtasks for {main_task_id}, found {len(subtasks)}\"\n        )\n\n    # Verify subtask content (S&P negotiation, connector build, testing)\n    subtask_names = [task[\"name\"].lower() for task in subtasks]\n    expected_keywords = [\"s&p\", \"connector\", \"test\"]\n\n    for keyword in expected_keywords:\n        if not any(keyword in name for name in subtask_names):\n            raise AssertionError(f\"Missing subtask containing '{keyword}' keyword\")\n\n    # Check for blocking relationship to data processing pipeline refactor\n    blocking_relationships = (\n        after.table(\"issue_relationships\")\n        .eq(\"target_issue_id\", main_task_id)\n        .eq(\"relationship_type\", \"blocks\")\n        .all()\n    )\n    pipeline_refactor_found = False\n\n    for rel in blocking_relationships:\n        if rel[\"source_issue_id\"] == \"SCRUM-1128\":\n            pipeline_refactor_found = True\n            break\n\n    if not pipeline_refactor_found:\n        raise AssertionError(\n            \"Main task should be blocked by data processing pipeline refactor ticket (SCRUM-1128)\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_relationships\": {\"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected changes: main task + 3 subtasks + blocking relationship\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": main_task_id, \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    for subtask in subtasks:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": subtask[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Add the blocking relationship\n    for rel in blocking_relationships:\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": rel[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "pagerduty-monitoring-done",
            "problem": "Can you mark 'done' my pagerduty task and its parent?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_pagerduty_monitoring_done(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-586 and DEBT-584 are marked as Done\"\"\"\n    # Check final state\n    after.table(\"issues\").eq(\"id\", \"DEBT-586\").assert_eq(\"board_list\", \"Done\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-584\").assert_eq(\"board_list\", \"Done\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Enforce invariant: nothing else changed (with ignore configuration)\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-586\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-584\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "assign-raj-data-ai-workflow-issues",
            "problem": "Assign Raj all the issues in the AI workflow project that has the word 'data' in the title. Skip all subtasks.",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_assign_raj_data_ai_workflow_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate AI workflow issues with 'data' in title are assigned to Raj Patel\"\"\"\n\n    issue_ids = [\"AIWORK-117\", \"AIWORK-182\", \"AIWORK-186\", \"AIWORK-277\"]\n\n    # Get Raj Patel's user ID\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_id = raj_user[\"id\"]\n\n    # Verify all issues are assigned to Raj Patel\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": raj_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specified issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "link-real-time-data-monitoring-tasks",
            "problem": "Find the Implement real-time data ingestion task set and make sure the data quality and consistency sub-task is linked as implemented by the automated data quality monitoring set of tasks",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_link_real_time_data_monitoring_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1059 is implemented by SCRUM-625\"\"\"\n    # Check that the implementation relationship exists\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-1059\")\n        .eq(\"target_issue_id\", \"SCRUM-625\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected SCRUM-1059 to be implemented by SCRUM-625\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the relationship was added\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "add-high-priority-label-to-caching",
            "problem": "Can you add a 'High Priority' label to my subtask (not issue) that implements a caching mechanism in our AI workflow builder? It's in the platform eng project.",
            "category": "label_and_priority_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_add_high_priority_label_to_caching(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-914 has the high-priority label\"\"\"\n    # Check that SCRUM-914 has the \"high-priority\" label\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n\n    label_id = high_priority_label[\"id\"]\n\n    # Verify SCRUM-914 has this label\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-914\").eq(\n        \"label_id\", label_id\n    ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected changes occurred - label creation (if new) and assignment\n    expected_changes = [\n        {\n            \"table\": \"issue_labels\",\n            \"pk\": (\"SCRUM-914\", label_id),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Check if the label was newly created\n    before_label = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    if not before_label:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": label_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "delete-a-b-testing-issue",
            "problem": "I think A/B testing this early is a bad idea. Can you delete those issues?",
            "category": "other",
            "difficulty": "medium",
            "verifier_func": "async def validate_delete_a_b_testing_issue(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that AIWORK-137 has been deleted\"\"\"\n    issue_ids = [\n        \"AIWORK-137\",\n        \"AIWORK-138\",\n        \"AIWORK-139\",\n        \"AIWORK-140\",\n        \"AIWORK-141\",\n        \"AIWORK-250\",\n    ]\n\n    # Verify the issue no longer exists\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_none()\n\n    # Verify it existed before deletion\n    for issue_id in issue_ids:\n        before.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"issue_labels\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_watchers\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_voters\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - issue deletion and any related data\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Check if issue was in any sprint and add sprint removal if needed\n    for issue_id in issue_ids:\n        before_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if before_sprint_assignment:\n            sprint_id = before_sprint_assignment[\"sprint_id\"]\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (sprint_id, issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n    # Verify only expected deletions occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "dark-mode-access",
            "problem": "Can you add a label \"High Priority\" to the dark mode task (SCRUM-664) in Platform Engineering? Please also add a comment saying \"Flagging as high priority due to accessibility requirements\". The environment does not have access to JQL, so do not use it to search.",
            "category": "label_and_priority_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_dark_mode_access(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-664 has High Priority label and accessibility comment\"\"\"\n    # Check that High Priority label exists and is assigned to SCRUM-664\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-664\").eq(\n        \"label_id\", high_priority_label[\"id\"]\n    ).assert_exists()\n\n    # Check that SCRUM-664 has exactly 3 comment with accessibility message\n    comments = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SCRUM-664\")\n        .eq(\"type\", \"Comment\")\n        .all()\n    )\n\n    if len(comments) != 3:\n        raise AssertionError(f\"Expected 3 comment on SCRUM-664, found {len(comments)}\")\n\n    comment = comments[-1]\n    comment_details = comment.get(\"details\", \"\").lower()\n    if (\n        \"flagging as high priority due to accessibility requirements\"\n        not in comment_details\n    ):\n        raise AssertionError(\n            f\"Expected comment to contain accessibility message, but found: {comment_details}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\", \"activities\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_labels\",\n            \"pk\": (\"SCRUM-664\", high_priority_label[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"activities\",\n            \"pk\": comment[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Check if High Priority label was newly created\n    before_label = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    if not before_label:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_label[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "create-mongodb-and-link-support-ticket",
            "problem": "Can you create a new task in product eng to fix the data connector to MongoDB support issue, marking the support issue as implemented by the new task?",
            "category": "task_creation_and_subtask_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_create_mongodb_and_link_support_ticket(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that SCRUM-1340 exists and SUP-417 is implemented by it\"\"\"\n    # Verify SCRUM-1340 exists\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n\n    # Verify SUP-417 is implemented by SCRUM-1340\n    implementation_relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SUP-417\")\n        .eq(\"target_issue_id\", \"SCRUM-1340\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n    if not implementation_relationship:\n        raise AssertionError(\"Expected SUP-417 to be implemented by SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected changes - only the implementation relationship\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": implementation_relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-1340\",\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "plan-voice-ai-sprint",
            "problem": "I need you to organize my AI workflow intelligence project. Create a sprint and add all tasks related to voice-to-workflow creation to this sprint. The environment does not have access to JQL, so do not use it to search.",
            "category": "project_and_sprint_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_plan_voice_ai_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning sprint for AI workflow intelligence project with voice/speech tasks\"\"\"\n\n    # List of voice/speech related issues that should be moved to sprint_8\n    voice_ai_issues = [\n        \"AIWORK-77\",\n        \"AIWORK-82\",\n        \"AIWORK-89\",\n        \"AIWORK-94\",\n        \"AIWORK-97\",\n    ]\n\n    # Verify all voice AI issues are now in sprint_8\n    for issue_id in voice_ai_issues:\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint creation\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Sprint assignments - move issues from original sprints to sprint_8\n    for issue_id in voice_ai_issues:\n        # Find the original sprint for this issue\n        original_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if original_sprint_assignment:\n            original_sprint_id = original_sprint_assignment[\"sprint_id\"]\n            expected_changes.extend(\n                [\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (original_sprint_id, issue_id),\n                        \"field\": None,\n                        \"after\": \"__removed__\",\n                    },\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (\"sprint_8\", issue_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    },\n                ]\n            )\n        else:\n            # Issue wasn't in any sprint before, just add to sprint_8\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_8\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "data-pipeline-tickets-blocked-by-refactor",
            "problem": "Our refactors are taking a while and we can't do any data pipeline work until it's done. Can you find my optimize data pipeline query performance ticket and my investigate data pipeline bottlenecks pipeline, and mark it as blocked by refactoring the data processing pipeline?",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_data_pipeline_tickets_blocked_by_refactor(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-583, SCRUM-597 are blocked by SCRUM-1128\"\"\"\n    expected_blocked_issues = [\"SCRUM-583\", \"SCRUM-597\"]\n    blocking_issue = \"SCRUM-1128\"\n\n    relationships = []\n\n    # Check that both SCRUM-583 and SCRUM-597 are blocked by SCRUM-1128\n    for blocked_issue in expected_blocked_issues:\n        relationship = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", blocking_issue)\n            .eq(\"target_issue_id\", blocked_issue)\n            .eq(\"relationship_type\", \"blocks\")\n            .first()\n        )\n\n        if not relationship:\n            raise AssertionError(\n                f\"Expected {blocked_issue} to be blocked by {blocking_issue}\"\n            )\n\n        relationships.append(relationship)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected relationships were added\n    expected_changes = []\n    for relationship in relationships:\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "revert-ui-changes",
            "problem": "We did the UI wrong. Can you move all tasks labeled \"UI\" in the platform eng project from done to in progress in current active sprints?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_revert_ui_changes(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that UI tasks in platform eng project are moved from done to in progress in current active sprints\"\"\"\n    expected_issue_ids = [\n        \"SCRUM-676\",\n        \"SCRUM-1205\",\n        \"SCRUM-1210\",\n    ]\n\n    # Verify all issues are marked as \"In Progress\"\n    for issue_id in expected_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in expected_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"In Progress\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "finish-testing",
            "problem": "We've completed all testing tasks in platform engineering. Can you mark all task/story issues in platform eng with label \"Testing\" that are currently in progress as done?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_finish_testing(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that testing tasks in platform engineering are marked as done\"\"\"\n    expected_issue_ids = [\"SCRUM-1211\", \"SCRUM-1275\"]\n\n    # Verify all issues are marked as \"Done\"\n    for issue_id in expected_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"Done\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in expected_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "bigquery-outage-is-google-fault",
            "problem": "The bigquery issue a user reported in support is not our fault and related to a GCP outage. Can you go into that ticket to thank the user for their patience and note that Google has resolved the issue? And then move that support ticket to Done",
            "category": "comments_and_communication",
            "difficulty": "medium",
            "verifier_func": "async def validate_bigquery_outage_is_google_fault(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify SUP-447 is Done and has 3 public comments\"\"\"\n    # Verify issue is marked as Done\n    after.table(\"issues\").eq(\"id\", \"SUP-447\").assert_eq(\"board_list\", \"Done\")\n\n    # Count public comments for SUP-447\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-447\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .count()\n        .value\n    )\n\n    if comment_count != 3:\n        raise AssertionError(\n            f\"Expected 3 public comments on SUP-447, found {comment_count}\"\n        )\n\n    # Verify exactly one new comment was added\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-447\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1. Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\", \"activities\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Find the new comment\n    all_after_comments = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-447\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .all()\n    )\n    all_before_comments = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-447\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .all()\n    )\n\n    before_ids = {comment[\"id\"] for comment in all_before_comments}\n    new_comments = [\n        comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n    ]\n\n    if len(new_comments) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new comment, found {len(new_comments)}\"\n        )\n\n    new_comment_id = new_comments[0][\"id\"]\n\n    # Expected changes - board_list update and new comment\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SUP-447\",\n            \"field\": \"board_list\",\n            \"after\": \"Done\",\n        },\n        {\n            \"table\": \"activities\",\n            \"pk\": new_comment_id,\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "move-unstarted-api-gateway-work-to-sprint7",
            "problem": "Someone overloaded the 2nd sprint within the tech debt and infrastructure overhaul projet. Can you find all core API gateway work that aren't marked in progress or later and move these to the subsequent sprint?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_move_unstarted_api_gateway_work_to_sprint7(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate API gateway work is moved to sprint 7\"\"\"\n    expected_issues = [\"DEBT-271\", \"DEBT-276\"]\n\n    # Check all issues are in sprint_7\n    for issue_id in expected_issues:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if not sprint_assignment:\n            raise AssertionError(f\"Issue {issue_id} is not assigned to any sprint\")\n\n        if sprint_assignment.get(\"sprint_id\") != \"sprint_7\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in sprint_7, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id')}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - need to handle previous assignments\n    expected_changes = []\n    for issue_id in expected_issues:\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if before_assignment and before_assignment.get(\"sprint_id\") != \"sprint_7\":\n            # Remove from old sprint\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (before_assignment.get(\"sprint_id\"), issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        # Add to sprint_7 (or keep if already there)\n        if not before_assignment or before_assignment.get(\"sprint_id\") != \"sprint_7\":\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_7\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "mark-network-microsegmentation-issue-implemented",
            "problem": "We created a duplicate in tech debt. Go into sprint 7 and add a relationship between the network micro-segmentation and the optimize network calls that's already in an active sprint in the platform engineering project, with relationship \"implemented by\".",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_mark_network_microsegmentation_issue_implemented(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-199 is implemented by SCRUM-690\"\"\"\n    # Check that the implementation relationship exists\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"DEBT-199\")\n        .eq(\"target_issue_id\", \"SCRUM-690\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected DEBT-199 to be implemented by SCRUM-690\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the relationship was added\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "add-offline-data-corruption-block",
            "problem": "Can you add a linked issue to my fix offline data corruption bug in sprint 3? Mark it as blocked by implementing offline data sync.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_add_offline_data_corruption_block(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-688 is blocked by SCRUM-681\"\"\"\n    # Check that SCRUM-688 is blocked by SCRUM-681\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-681\")\n        .eq(\"target_issue_id\", \"SCRUM-688\")\n        .eq(\"relationship_type\", \"blocks\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected SCRUM-688 to be blocked by SCRUM-681\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected relationship was added\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "give-raj-more-bugs",
            "problem": "In the platform engineering project, assign all currently unassigned bugs to Raj across all sprints / backlog, except the data pipeline bug (assign that one to me). Don't stop until you're done.",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_give_raj_more_bugs(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that all bugs except data pipeline bug are assigned to Raj Patel, and SCRUM-555 is assigned to Sarah Kim\"\"\"\n    # Get user IDs\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n\n    sarah_kim_id = sarah_kim_user[\"id\"]\n    raj_id = raj_user[\"id\"]\n\n    # Verify SCRUM-555 is assigned to Sarah Kim\n    after.table(\"issues\").eq(\"id\", \"SCRUM-555\").assert_eq(\"owner\", sarah_kim_id)\n\n    # Verify all other bugs are assigned to Raj Patel\n    other_bugs = [\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-790\",\n        \"SCRUM-822\",\n        \"SCRUM-882\",\n        \"SCRUM-897\",\n        \"SCRUM-956\",\n        \"SCRUM-1331\",\n    ]\n    for bug_id in other_bugs:\n        after.table(\"issues\").eq(\"id\", bug_id).assert_eq(\"owner\", raj_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # SCRUM-555 assigned to Sarah Kim\n    expected_changes.append(\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-555\",\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        }\n    )\n\n    # Other bugs assigned to Raj Patel\n    for bug_id in other_bugs:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": bug_id,\n                \"field\": \"owner\",\n                \"after\": raj_id,\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "churn-prediction-model-duplicate-issues",
            "problem": "Someone created an issue in the platform engineering project to predict customer churn, but I already created an epic for this in the AI workflow project. I think my epic is more descriptive. I want you to set my \"Develop churn prediction model\" issue from my Platform Eng project as implemented by my churn prevention engine epic from my AI Workflow project.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_churn_prediction_model_duplicate_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-886 is implemented by AIWORK-208\"\"\"\n    # Check that SCRUM-886 is implemented by AIWORK-208\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-886\")\n        .eq(\"target_issue_id\", \"AIWORK-208\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected SCRUM-886 to be implemented by AIWORK-208\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "assign-legacy-bridge-to-marcus",
            "problem": "Can you assign all the legacy API bridge tickets / sub tickets to Marcus?",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_assign_legacy_bridge_to_marcus(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-159 through 165 are assigned to Marcus Johnson\"\"\"\n    issue_ids = [\n        \"AIWORK-159\",\n        \"AIWORK-160\",\n        \"AIWORK-161\",\n        \"AIWORK-162\",\n        \"AIWORK-163\",\n        \"AIWORK-164\",\n        \"AIWORK-165\",\n    ]\n\n    # Get Marcus Johnson's user ID\n    marcus_johnson_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n    if not marcus_johnson_user:\n        raise AssertionError(\"User 'Marcus Johnson' not found\")\n    marcus_johnson_id = marcus_johnson_user[\"id\"]\n\n    # Check that all issues are assigned to Marcus Johnson\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", marcus_johnson_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": marcus_johnson_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "apache-spark-duplicate",
            "problem": "Mark the apache spark issue within the AI workflow project as 'duplicates' my distributed data processing task in platform engineering",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_apache_spark_duplicate(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-186 and SCRUM-611 are marked as duplicates\"\"\"\n    # Check for duplicate relationship in either direction\n    relationship1 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"AIWORK-186\")\n        .eq(\"target_issue_id\", \"SCRUM-611\")\n        .eq(\"relationship_type\", \"duplicates\")\n        .first()\n    )\n\n    relationship2 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-611\")\n        .eq(\"target_issue_id\", \"AIWORK-186\")\n        .eq(\"relationship_type\", \"duplicates\")\n        .first()\n    )\n\n    if not relationship1 and not relationship2:\n        raise AssertionError(\n            \"Expected AIWORK-186 and SCRUM-611 to be marked as duplicates\"\n        )\n\n    relationship = relationship1 or relationship2\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "move-mobile-tasks-from-packed-sprint",
            "problem": "Our active sprints in the platform engineering project are getting way too packed. Can you find all mobile app v2 tickets presently within active sprints of the platform engineering project that aren't marked In Progress or later and move these to sprint 3?",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_move_mobile_tasks_from_packed_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate mobile app v2 tickets are moved to sprint 3\"\"\"\n    expected_issues = [\n        \"SCRUM-716\",\n        \"SCRUM-690\",\n        \"SCRUM-664\",\n        \"SCRUM-1198\",\n        \"SCRUM-726\",\n        \"SCRUM-669\",\n        \"SCRUM-658\",\n    ]\n\n    # Check all issues are in sprint_3\n    for issue_id in expected_issues:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if not sprint_assignment:\n            raise AssertionError(f\"Issue {issue_id} is not assigned to any sprint\")\n\n        if sprint_assignment.get(\"sprint_id\") != \"sprint_3\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in sprint_3, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id')}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - need to handle previous assignments\n    expected_changes = []\n    for issue_id in expected_issues:\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if before_assignment and before_assignment.get(\"sprint_id\") != \"sprint_3\":\n            # Remove from old sprint\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (before_assignment.get(\"sprint_id\"), issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        # Add to sprint_3 (or keep if already there)\n        if not before_assignment or before_assignment.get(\"sprint_id\") != \"sprint_3\":\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_3\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "caching-workflow-builder-duplicate",
            "problem": "Go to the \"Caching Layer Implementation\" issue within the technical debt project and mark this as a duplicate of the \"Implement Caching Mechanism for AI Workflow Builder\" issue from the Product Engineering project.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_caching_workflow_builder_duplicate(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-781 and SCRUM-912 are marked as duplicates\"\"\"\n    # Check for duplicate relationship in either direction\n    relationship1 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"DEBT-781\")\n        .eq(\"target_issue_id\", \"SCRUM-912\")\n        .eq(\"relationship_type\", \"duplicates\")\n        .first()\n    )\n\n    relationship2 = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-912\")\n        .eq(\"target_issue_id\", \"DEBT-781\")\n        .eq(\"relationship_type\", \"duplicates\")\n        .first()\n    )\n\n    if not relationship1 and not relationship2:\n        raise AssertionError(\n            \"Expected DEBT-781 and SCRUM-912 to be marked as duplicates\"\n        )\n\n    relationship = relationship1 or relationship2\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "put-in-review-urge",
            "problem": "Move all tasks labeled \"Feature\" in the engineering project that are currently in progress into in review. Out of these issues, find the one that's in sprint 2, navigate to its parent epic, and leave a comment urging faster development. I'd suggest using the backlog view for this task.",
            "category": "task_status_and_progress_updates",
            "difficulty": "medium",
            "verifier_func": "async def validate_put_in_review_urge(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-541, SCRUM-1128, SCRUM-1305 are moved to In Review and SCRUM-528 has 3 comments\"\"\"\n    review_issue_ids = [\"SCRUM-541\", \"SCRUM-1128\", \"SCRUM-1305\"]\n\n    # Verify specific issues are marked as \"In Review\"\n    for issue_id in review_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Review\")\n\n    # Count comments for SCRUM-528\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SCRUM-528\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    # Verify exactly one new comment was added to SCRUM-528\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SCRUM-528\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1. Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\", \"activities\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Find the new comment for SCRUM-528\n    all_after_comments = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SCRUM-528\")\n        .eq(\"type\", \"Comment\")\n        .all()\n    )\n    all_before_comments = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SCRUM-528\")\n        .eq(\"type\", \"Comment\")\n        .all()\n    )\n\n    before_ids = {comment[\"id\"] for comment in all_before_comments}\n    new_comments = [\n        comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n    ]\n\n    if len(new_comments) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new comment, found {len(new_comments)}\"\n        )\n\n    new_comment_id = new_comments[0][\"id\"]\n\n    # Expected changes - board_list updates for review issues and new comment for SCRUM-528\n    expected_changes = []\n\n    # Add board_list changes for review issues\n    for issue_id in review_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"In Review\",\n            }\n        )\n\n    # Add new comment for SCRUM-528\n    expected_changes.append(\n        {\n            \"table\": \"activities\",\n            \"pk\": new_comment_id,\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "take-raj-off-automated-data-export",
            "problem": "I'm taking over everything related to data import and export on the platform since Raj is overwhelmed. I need you to re-assign all of the automate data import tasks and sub-tasks to me except for any tasks that are already marked Done - we can leave any of those with Raj.",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_take_raj_off_automated_data_export(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that automated data import tasks are reassigned to Sarah Kim\"\"\"\n    issue_ids = [\n        \"SCRUM-1305\",\n        \"SCRUM-1306\",\n        \"SCRUM-1307\",\n        \"SCRUM-1308\",\n        \"SCRUM-1309\",\n        \"SCRUM-1311\",\n    ]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check that the specified issues are assigned to Sarah Kim, except Done ones\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        # Only reassign if not already Done\n        if issue.get(\"board_list\") != \"Done\":\n            after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list for issues that were reassigned\n    expected_changes = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if issue and issue.get(\"board_list\") != \"Done\":\n            expected_changes.append(\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"owner\",\n                    \"after\": sarah_kim_id,\n                }\n            )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "too-much-soc2-on-the-dance-floor",
            "problem": "Someone created a duplicate compliance epic. Go to the \"Data Governance and Compliance\" epic within the platform engineering project and mark this as a duplicate of the SOC 2 epic from the technical debt project.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_too_much_soc2_on_the_dance_floor(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-515 duplicates DEBT-163\"\"\"\n    # Check for duplicate relationship\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-515\")\n        .eq(\"target_issue_id\", \"DEBT-163\")\n        .eq(\"relationship_type\", \"duplicates\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected SCRUM-515 to be marked as duplicate of DEBT-163\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "monitoring-implemented-by",
            "problem": "I remember someone recommended a monitoring solution vendor for pg_stat_statements. Can you find the suggestion, then \"Add\" -> \"linked issue\" between the deploy pg_stat_statements issue and the ticket implementing the suggested vendor (this ticket will have the vendor's name in it), with relationship 'implemented by'? If there are duplicates, any of them will work.",
            "category": "dependency_and_blocking_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_monitoring_implemented_by(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-528 is implemented by one of the monitoring solution tickets\"\"\"\n    # Check that DEBT-528 is implemented by one of the monitoring tickets\n    monitoring_tickets = [\"DEBT-285\", \"DEBT-425\", \"DEBT-581\", \"DEBT-639\", \"DEBT-642\"]\n\n    implementation_found = False\n    for ticket_id in monitoring_tickets:\n        relationship = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", \"DEBT-528\")\n            .eq(\"target_issue_id\", ticket_id)\n            .eq(\"relationship_type\", \"is_implemented_by\")\n            .first()\n        )\n        if relationship:\n            implementation_found = True\n            break\n\n    if not implementation_found:\n        raise AssertionError(\n            f\"Expected DEBT-528 to be implemented by one of {monitoring_tickets}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "move-sprints-api-gateway",
            "problem": "Looks like we're ahead of schedule and can take on a bit more work. I want you to move all tasks in sprint 6 related to our core api gateway work that are not currently in progress or in review to sprint 5",
            "category": "project_and_sprint_management",
            "difficulty": "medium",
            "verifier_func": "async def validate_move_sprints_api_gateway(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate api gateway v2 tickets are moved to sprint 5\"\"\"\n    expected_issues = [\n        \"DEBT-271\",\n        \"DEBT-276\",\n    ]\n\n    for issue_id in expected_issues:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if not sprint_assignment:\n            raise AssertionError(f\"Issue {issue_id} is not assigned to any sprint\")\n\n        if sprint_assignment.get(\"sprint_id\") != \"sprint_5\":\n            raise AssertionError(\n                f\"Issue {issue_id} should be in sprint_5, \"\n                f\"but is in sprint {sprint_assignment.get('sprint_id')}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - need to handle previous assignments\n    expected_changes = []\n    for issue_id in expected_issues:\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n\n        if before_assignment and before_assignment.get(\"sprint_id\") != \"sprint_5\":\n            # Remove from old sprint\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (before_assignment.get(\"sprint_id\"), issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        # Add to sprint_3 (or keep if already there)\n        if not before_assignment or before_assignment.get(\"sprint_id\") != \"sprint_5\":\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_5\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "assign-thomas-delete-archive-support",
            "problem": "Thomas has some free time and offered to help on some tasks. Can you assign Thomas Lee all unassigned issues in the support project that has the word 'archive' or 'delete' in the title?",
            "category": "task_assignment_and_ownership",
            "difficulty": "medium",
            "verifier_func": "async def validate_assign_thomas_delete_archive_support(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate support issues are assigned to Thomas Lee\"\"\"\n\n    issue_ids = [\"SUP-439\", \"SUP-449\", \"SUP-459\"]\n\n    # Get Thomas Lee's user ID\n    thomas_user = after.table(\"users\").eq(\"name\", \"Thomas Lee\").first()\n    if not thomas_user:\n        raise AssertionError(\"User 'Thomas Lee' not found\")\n    thomas_id = thomas_user[\"id\"]\n\n    # Verify all issues are assigned to Thomas Lee\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", thomas_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": thomas_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specified issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "rename-epic",
            "problem": "Can you rename my Improve AI workflow builder performance improvements epic to \"Workflow Builder v2\", change the description too while you're at it? Remember, you have to click on the edit icon to edit the title.",
            "category": "epic_management_and_organization",
            "difficulty": "easy",
            "verifier_func": "async def validate_rename_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-493 is renamed to 'Workflow Builder v2'\"\"\"\n    # Check final state\n    after.table(\"issues\").eq(\"id\", \"SCRUM-493\").assert_eq(\"name\", \"Workflow Builder v2\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Get the description from the after state\n    issue_after = after.table(\"issues\").eq(\"id\", \"SCRUM-493\").first()\n    description_after = issue_after[\"description\"] if issue_after else None\n\n    # Enforce invariant: only the name and description fields of SCRUM-493 changed\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-493\",\n            \"field\": \"name\",\n            \"after\": \"Workflow Builder v2\",\n        },\n    ]\n\n    if description_after is not None:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-493\",\n                \"field\": \"description\",\n                \"after\": description_after,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "take-raj-off-bigquery",
            "problem": "We're taking Raj off of bigquery tasks so that he can focus on his work data processing pipeline. I need you to go into Raj's BigQuery optimization ticket and re-assign all of his tasks and sub-tasks to me that aren't already marked Done. If anyone else is assigned to tasks, leave them as-is, the other assignees can handle those tasks.",
            "category": "task_assignment_and_ownership",
            "difficulty": "easy",
            "verifier_func": "async def validate_take_raj_off_bigquery(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that Raj's BigQuery tasks (DEBT-621, DEBT-625) are reassigned to Sarah Kim\"\"\"\n    issue_ids = [\"DEBT-621\", \"DEBT-625\"]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check that the specified issues are assigned to Sarah Kim and not marked Done\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        # Only reassign if not already Done\n        if issue.get(\"board_list\") != \"Done\":\n            after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list for issues that were reassigned\n    expected_changes = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if issue and issue.get(\"board_list\") != \"Done\":\n            expected_changes.append(\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"owner\",\n                    \"after\": sarah_kim_id,\n                }\n            )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "punt-some-tasks-to-later-sprints",
            "problem": "We're falling behind on some work in the platform engineering project so we need to re-organize our sprints. Move the ai workflow builder tasks that haven't been started yet from sprint 1 to sprint 2, and then move both the research test automation tools and the implement test automation framework tasks to the next upcoming planned sprint.",
            "category": "project_and_sprint_management",
            "difficulty": "easy",
            "verifier_func": "async def validate_punt_some_tasks_to_later_sprints(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate sprint reassignments: SCRUM-530 to sprint_2, SCRUM-1156 and SCRUM-1164 to sprint_3\"\"\"\n    # Verify SCRUM-530 is in sprint_2\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-530\").assert_eq(\n        \"sprint_id\", \"sprint_2\"\n    )\n\n    # Verify SCRUM-1156 and SCRUM-1164 are in sprint_3\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1156\").assert_eq(\n        \"sprint_id\", \"sprint_3\"\n    )\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1164\").assert_eq(\n        \"sprint_id\", \"sprint_3\"\n    )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Handle SCRUM-530 move from sprint_1 to sprint_2\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_1\", \"SCRUM-530\"),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            },\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_2\", \"SCRUM-530\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    # Handle SCRUM-1156 and SCRUM-1164 moves from sprint_2 to sprint_3\n    for issue_id in [\"SCRUM-1156\", \"SCRUM-1164\"]:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_2\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_3\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "plan-first-ai-workflow-platform-sprint",
            "problem": "I want to get started on my AI workflow intelligence platform. Can you plan sprint 1? First, create a new sprint in the AI workflow project. Then, find all of the issues that sit under the core NLP infra epic. Next, move all of these tasks into the new sprint you created. Finally, assign each of these tasks to whoever reported the issue.",
            "category": "project_and_sprint_management",
            "difficulty": "easy",
            "verifier_func": "async def validate_plan_first_ai_workflow_platform_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning sprint 1 for AI workflow platform with epic-based assignments\"\"\"\n\n    # Define issue assignments based on who reported them\n    raj_issues = [\n        \"AIWORK-2\",\n        \"AIWORK-11\",\n    ]\n    elena_issues = [\n        \"AIWORK-6\",\n        \"AIWORK-22\",\n    ]\n    marcus_issues = [\"AIWORK-17\"]\n\n    all_sprint_8_issues = raj_issues + elena_issues + marcus_issues\n\n    # Get user IDs for the assignees\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    elena_user = after.table(\"users\").eq(\"name\", \"Elena Rodriguez\").first()\n    marcus_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    if not elena_user:\n        raise AssertionError(\"User 'Elena Rodriguez' not found\")\n    if not marcus_user:\n        raise AssertionError(\"User 'Marcus Johnson' not found\")\n\n    raj_id = raj_user[\"id\"]\n    elena_id = elena_user[\"id\"]\n    marcus_id = marcus_user[\"id\"]\n\n    # Check each issue is in sprint_8 and has correct owner\n    for issue_id in raj_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    for issue_id in elena_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", elena_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    for issue_id in marcus_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", marcus_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint creation\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Issue owner assignments\n    for issue_id in raj_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": raj_id}\n        )\n    for issue_id in elena_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": elena_id}\n        )\n    for issue_id in marcus_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": marcus_id}\n        )\n\n    # Sprint assignments\n    for issue_id in all_sprint_8_issues:\n        # Find the original sprint for this issue\n        original_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if original_sprint_assignment:\n            original_sprint_id = original_sprint_assignment[\"sprint_id\"]\n            expected_changes.extend(\n                [\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (original_sprint_id, issue_id),\n                        \"field\": None,\n                        \"after\": \"__removed__\",\n                    },\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (\"sprint_8\", issue_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    },\n                ]\n            )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "find-and-comment-on-unassigned-ticket",
            "problem": "Find the unassigned incident support ticket and leave a comment to let the client know that we're on the case.",
            "category": "comments_and_communication",
            "difficulty": "easy",
            "verifier_func": "async def validate_find_and_comment_on_unassigned_ticket(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SUP-368 has one more comment than before\"\"\"\n    # Count comments for SUP-368\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-368\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    # Verify exactly one new comment was added\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-368\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1 for SUP-368. \"\n            f\"Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Find the new comment\n    all_after_comments = (\n        after.table(\"activities\").eq(\"issue_id\", \"SUP-368\").eq(\"type\", \"Comment\").all()\n    )\n    all_before_comments = (\n        before.table(\"activities\").eq(\"issue_id\", \"SUP-368\").eq(\"type\", \"Comment\").all()\n    )\n\n    before_ids = {comment[\"id\"] for comment in all_before_comments}\n    new_comments = [\n        comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n    ]\n\n    if len(new_comments) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new comment, found {len(new_comments)}\"\n        )\n\n    new_comment_id = new_comments[0][\"id\"]\n\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"activities\",\n                \"pk\": new_comment_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "add-mobile-subtasks-to-marcus",
            "problem": "Marcus has been making great progress on improving app startup time so let's give him more work. Go into the backlog to search for the mobile apps issues and find: 1) the two factor auth issue; and 2) the biometric auth issue. Once you found them, assign them to Marcus.",
            "category": "task_assignment_and_ownership",
            "difficulty": "easy",
            "verifier_func": "async def validate_add_mobile_subtasks_to_marcus(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-731 and SCRUM-745 are now owned by Marcus Johnson\"\"\"\n    # Get Marcus Johnson's user ID\n    marcus_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n    if not marcus_user:\n        raise AssertionError(\"Marcus Johnson user not found\")\n    marcus_user_id = marcus_user[\"id\"]\n\n    # Check both issues now have Marcus as owner\n    after.table(\"issues\").eq(\"id\", \"SCRUM-731\").assert_eq(\"owner\", marcus_user_id)\n    after.table(\"issues\").eq(\"id\", \"SCRUM-745\").assert_eq(\"owner\", marcus_user_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only epic_id and owner fields changed\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-731\",\n                \"field\": \"owner\",\n                \"after\": marcus_user_id,\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-745\",\n                \"field\": \"owner\",\n                \"after\": marcus_user_id,\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "tag-multi-language-nlp-task",
            "problem": "Go to the multi-lanuage nlp models issue from the AI workflow project and make sure it's tagged as a Translation task.",
            "category": "label_and_priority_management",
            "difficulty": "easy",
            "verifier_func": "async def validate_tag_multi_language_nlp_task(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-107 has High Priority, Machine Learning, Multi-Language, NLP, and Translation labels\"\"\"\n    # Check that required labels exist\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    ml_label = after.table(\"labels\").eq(\"name\", \"Machine Learning\").first()\n    multi_lang_label = after.table(\"labels\").eq(\"name\", \"Multi-Language\").first()\n    nlp_label = after.table(\"labels\").eq(\"name\", \"NLP\").first()\n    translation_label = after.table(\"labels\").eq(\"name\", \"Translation\").first()\n\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n    if not ml_label:\n        raise AssertionError(\"Expected 'Machine Learning' label to exist\")\n    if not multi_lang_label:\n        raise AssertionError(\"Expected 'Multi-Language' label to exist\")\n    if not nlp_label:\n        raise AssertionError(\"Expected 'NLP' label to exist\")\n    if not translation_label:\n        raise AssertionError(\"Expected 'Translation' label to exist\")\n\n    high_priority_id = high_priority_label[\"id\"]\n    ml_id = ml_label[\"id\"]\n    multi_lang_id = multi_lang_label[\"id\"]\n    nlp_id = nlp_label[\"id\"]\n    translation_id = translation_label[\"id\"]\n\n    # Verify AIWORK-107 has exactly these five labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", ml_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", multi_lang_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", nlp_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", translation_id\n    ).assert_exists()\n\n    # Verify AIWORK-107 has exactly 5 labels\n    aiwork_107_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").count().value\n    )\n    if aiwork_107_labels != 5:\n        raise AssertionError(\n            f\"Expected AIWORK-107 to have exactly 5 labels, found {aiwork_107_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    before_ml = before.table(\"labels\").eq(\"name\", \"Machine Learning\").first()\n    before_multi_lang = before.table(\"labels\").eq(\"name\", \"Multi-Language\").first()\n    before_nlp = before.table(\"labels\").eq(\"name\", \"NLP\").first()\n    before_translation = before.table(\"labels\").eq(\"name\", \"Translation\").first()\n\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_ml:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": ml_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_multi_lang:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": multi_lang_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_nlp:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": nlp_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_translation:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": translation_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Get all labels AIWORK-107 had before and remove them\n    before_aiwork_107_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").all()\n    )\n    for old_assignment in before_aiwork_107_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", ml_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", multi_lang_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", nlp_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", translation_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "james-conference-reassign",
            "problem": "James Wilson is out for a conference right now. Can you re-assign all of his support tickets in progress to me?",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_james_conference_reassign(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that James Wilson's support tickets are reassigned to Sarah Kim\"\"\"\n    expected_issue_ids = [\"SUP-417\", \"SUP-447\", \"SUP-457\"]\n\n    # Get Sarah Kim's user ID\n    sarah_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_id = sarah_user[\"id\"]\n\n    # Verify all issues are assigned to Sarah Kim\n    for issue_id in expected_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in expected_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": sarah_id,\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "increase-estimate-typescript-migration",
            "problem": "I think we're massively underestimating the typescript migration epic. Can you increase the estimated story points to 3 months (180 story points)?",
            "category": "label_and_priority_management",
            "difficulty": "easy",
            "verifier_func": "async def validate_increase_estimate_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-793 has story_points set to 180\"\"\"\n    issue_id = \"DEBT-793\"\n\n    # Verify the issue has 180 story points\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"story_points\", 180)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected change - story points update\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"story_points\",\n            \"after\": 180,\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "iscf-mark-done",
            "problem": "Can you mark all the to-do and in progress subtasks to done in the \u201cImplement Security Control Framework\u201d issue, mark the entire task as done, and tag Thomas Lee telling him that I\u2019m done?",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_iscf_mark_done(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-164 through DEBT-168 are marked as Done and Elena Rodriguez leaves a comment\"\"\"\n    issue_ids = [\"DEBT-164\", \"DEBT-165\", \"DEBT-166\", \"DEBT-167\", \"DEBT-168\"]\n\n    # Verify all issues are marked as Done\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"Done\")\n\n    # Get Elena Rodriguez's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Find a comment from Elena Rodriguez that mentions \"@Thomas Lee\" and \"done\"\n    comments = (\n        after.table(\"activities\").eq(\"type\", \"Comment\").eq(\"author\", sarah_kim_id).all()\n    )\n\n    found_comment = None\n    for comment in comments:\n        details = comment.get(\"details\", \"\").lower()\n        if \"@thomas lee\" in details.lower() and \"done\" in details.lower():\n            found_comment = comment\n            break\n\n    if not found_comment:\n        raise AssertionError(\n            \"Expected comment from Sarah Kim mentioning '@Thomas Lee' and 'done'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\", \"activities\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            }\n        )\n\n    # Add the comment\n    expected_changes.append(\n        {\n            \"table\": \"activities\",\n            \"pk\": found_comment[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "mongodb-failures-response-karen",
            "problem": "We haven't responded to Karen Smith for her ticket reporting MongoDB failures. Can you leave a comment letting her know it's in the works, and will be done in the next few days in our support channel?",
            "category": "comments_and_communication",
            "difficulty": "easy",
            "verifier_func": "async def validate_mongodb_failures_response_karen(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that SUP-417 has 4 public comments\"\"\"\n    # Count public comments for SUP-417\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-417\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .count()\n        .value\n    )\n\n    if comment_count != 5:\n        raise AssertionError(\n            f\"Expected 5 public comments on SUP-417, found {comment_count}\"\n        )\n\n    # Verify exactly one new comment was added\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-417\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1. Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Find the new comment\n    all_after_comments = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-417\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .all()\n    )\n    all_before_comments = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-417\")\n        .eq(\"type\", \"Comment\")\n        .eq(\"action\", \"public\")\n        .all()\n    )\n\n    before_ids = {comment[\"id\"] for comment in all_before_comments}\n    new_comments = [\n        comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n    ]\n\n    if len(new_comments) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new comment, found {len(new_comments)}\"\n        )\n\n    new_comment_id = new_comments[0][\"id\"]\n\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"activities\",\n                \"pk\": new_comment_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "offer-to-help-phi-encryption",
            "problem": "Leave a quick comment on the PHI encryption ticket offering to help.",
            "category": "comments_and_communication",
            "difficulty": "easy",
            "verifier_func": "async def validate_offer_to_help_phi_encryption(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify DEBT-224 has 1 comment\"\"\"\n    # Count comments for DEBT-224\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-224\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != 1:\n        raise AssertionError(f\"Expected 1 comment on DEBT-224, found {comment_count}\")\n\n    # Verify this is a new comment\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-224\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1. Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Get the comment\n    comment = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-224\")\n        .eq(\"type\", \"Comment\")\n        .first()\n    )\n\n    if not comment:\n        raise AssertionError(\"No comment found on DEBT-224\")\n\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"activities\",\n                \"pk\": comment[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "escalate-decision-maker-issues",
            "problem": "Olivia Chang is a decision-maker at our biggest enterprise POC. Can you find all todo reports from her, put them into in progress, assign them to me, and mark as highest priority in our support channel?",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_escalate_decision_maker_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Olivia Chang's todo reports moved to In Progress, assigned to Sarah Kim, and marked as Highest priority\"\"\"\n    issue_ids = [\"SUP-374\", \"SUP-403\", \"SUP-429\"]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify all issues are assigned to Sarah Kim, in In Progress, and Highest priority\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"priority\", \"Highest\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"owner\",\n                    \"after\": sarah_kim_id,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"board_list\",\n                    \"after\": \"In Progress\",\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"priority\",\n                    \"after\": \"Highest\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "assign-my-support-tasks-to-thomas",
            "problem": "I'm going to be OOO next week. Can you re-assign all my support tasks to Thomas?",
            "category": "task_assignment_and_ownership",
            "difficulty": "easy",
            "verifier_func": "async def validate_assign_my_support_tasks_to_thomas(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate support tasks SUP-367, SUP-407, SUP-473 are assigned to Thomas Lee\"\"\"\n\n    issue_ids = [\"SUP-367\", \"SUP-407\", \"SUP-473\"]\n\n    # Get Thomas Lee's user ID\n    thomas_user = after.table(\"users\").eq(\"name\", \"Thomas Lee\").first()\n    if not thomas_user:\n        raise AssertionError(\"User 'Thomas Lee' not found\")\n    thomas_id = thomas_user[\"id\"]\n\n    # Verify all issues are assigned to Thomas Lee\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", thomas_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": thomas_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes for specified issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "suggest-etl-pipeline-overhaul",
            "problem": "Can you leave a comment in the ETL pipeline efficiency overhaul ticket with a few suggestions on how we can approach the problem?",
            "category": "comments_and_communication",
            "difficulty": "easy",
            "verifier_func": "async def validate_suggest_etl_pipeline_overhaul(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify DEBT-627 has 1 comment\"\"\"\n    # Count comments for DEBT-627\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-627\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != 1:\n        raise AssertionError(f\"Expected 1 comment on DEBT-627, found {comment_count}\")\n\n    # Verify this is a new comment\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-627\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1. Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Get the comment\n    comment = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"DEBT-627\")\n        .eq(\"type\", \"Comment\")\n        .first()\n    )\n\n    if not comment:\n        raise AssertionError(\"No comment found on DEBT-627\")\n\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"activities\",\n                \"pk\": comment[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        },
        {
            "id": "verify-soc2-evidence-gaps",
            "problem": "Maya is pulling together the SOC 2 evidence for the SOC 2 Type II epic. Can you find the human audit issue and cross-reference all of its subtasks \u2014 if any of its subtasks are missing owners or marked To Do, assign it to someone on our team. Do not modify the parent task.",
            "category": "task_assignment_and_ownership",
            "difficulty": "easy",
            "verifier_func": "async def validate_verify_soc2_evidence_gaps(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate SOC 2 evidence subtasks DEBT-180 through DEBT-184 all have owners\"\"\"\n\n    issue_ids = [\"DEBT-180\", \"DEBT-181\", \"DEBT-182\", \"DEBT-183\", \"DEBT-184\"]\n\n    # Verify all issues have owners (not null)\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        owner_id = issue.get(\"owner\")\n        if owner_id is None:\n            raise AssertionError(f\"Issue {issue_id} should have an owner assigned\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes for issues that were previously unassigned\n    expected_changes = []\n    for issue_id in issue_ids:\n        before_issue = before.table(\"issues\").eq(\"id\", issue_id).first()\n        after_issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n\n        if before_issue and after_issue:\n            if (\n                before_issue.get(\"owner\") is None\n                and after_issue.get(\"owner\") is not None\n            ):\n                expected_changes.append(\n                    {\n                        \"table\": \"issues\",\n                        \"pk\": issue_id,\n                        \"field\": \"owner\",\n                        \"after\": after_issue[\"owner\"],\n                    }\n                )\n\n    # Enforce invariant: only ownership changes for previously unassigned issues\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "create-sharepoint-epic",
            "problem": "I want to create a new epic and set of tasks for sprint 3 in platform engineering. I want you to create a Sharepoint integration epic (assigned to Raj, set to sprint 3). Then, I want you to create three tasks that are part of this epic: 1) build a Sharepoint data pipe; 2) build permissions syncing; and 3) set up a cron job to sync every 5 minutes. Make sure that, as you create the epic and 3 issues, you're assigning them to Raj and you're setting every single one as part of Sprint 3.",
            "category": "epic_management_and_organization",
            "difficulty": "easy",
            "verifier_func": "async def validate_create_sharepoint_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of Sharepoint integration epic and tasks for sprint_3 assigned to Raj Patel\"\"\"\n    # Find the new epic (should be > SCRUM-1340)\n    all_epics = after.table(\"issues\").eq(\"issue_type\", \"Epic\").all()\n\n    # Filter epics with numeric comparison\n    epic_candidates = []\n    for epic in all_epics:\n        epic_id = epic[\"id\"]\n        if epic_id.startswith(\"SCRUM-\"):\n            try:\n                epic_num = int(epic_id.split(\"-\")[1])\n                if epic_num > 1339:\n                    epic_candidates.append(epic)\n            except (ValueError, IndexError):\n                continue  # Skip malformed IDs\n\n    if not epic_candidates:\n        raise AssertionError(\"No new epic found with ID > SCRUM-1339\")\n\n    # Should be exactly one new epic\n    if len(epic_candidates) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new epic, found {len(epic_candidates)}\"\n        )\n\n    epic = epic_candidates[0]\n    epic_id = epic[\"id\"]\n\n    # Get Raj Patel's user ID\n    raj_patel_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_patel_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_patel_id = raj_patel_user[\"id\"]\n\n    # Verify epic is assigned to Raj Patel and in sprint_3\n    after.table(\"issues\").eq(\"id\", epic_id).assert_eq(\"owner\", raj_patel_id)\n    after.table(\"sprint_issues\").eq(\"issue_id\", epic_id).eq(\n        \"sprint_id\", \"sprint_3\"\n    ).assert_exists()\n\n    # Find the three new tasks (should be > SCRUM-1339 and have this epic_id)\n    task_candidates = (\n        after.table(\"issues\")\n        .neq(\"issue_type\", \"Epic\")\n        .gt(\"id\", \"SCRUM-1339\")\n        .eq(\"epic_id\", epic_id)\n        .all()\n    )\n\n    if len(task_candidates) != 3:\n        raise AssertionError(\n            f\"Expected exactly 3 new tasks for epic {epic_id}, found {len(task_candidates)}\"\n        )\n\n    # Verify all tasks are assigned to Raj Patel and in sprint_3\n    task_ids = []\n    for task in task_candidates:\n        task_id = task[\"id\"]\n        task_ids.append(task_id)\n        after.table(\"issues\").eq(\"id\", task_id).assert_eq(\"owner\", raj_patel_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", task_id).eq(\n            \"sprint_id\", \"sprint_3\"\n        ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_relationships\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes dynamically based on found IDs\n    expected_changes = [\n        # Epic creation and sprint assignment\n        {\"table\": \"issues\", \"pk\": epic_id, \"field\": None, \"after\": \"__added__\"},\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_3\", epic_id),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Task creations and sprint assignments\n    for task_id in task_ids:\n        expected_changes.extend(\n            [\n                {\"table\": \"issues\", \"pk\": task_id, \"field\": None, \"after\": \"__added__\"},\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_3\", task_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "mark-gdpr-items-in-review",
            "problem": "I'm finishing up my work on data mapping under the GDPR epic in the tech debt project. I need your help to find this ticket under the epic, mark it as \"in review\", then mark any of its outstanding sub-tasks that have not been completed as \"in review\", as well.",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_mark_gdpr_items_in_review(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that the GDPR items are marked as In Review\"\"\"\n    after.table(\"issues\").eq(\"id\", \"DEBT-210\").assert_eq(\"board_list\", \"In Review\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-212\").assert_eq(\"board_list\", \"In Review\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-213\").assert_eq(\"board_list\", \"In Review\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Enforce invariant: nothing else changed (with ignore configuration)\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-210\",\n                \"field\": \"board_list\",\n                \"after\": \"In Review\",\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-212\",\n                \"field\": \"board_list\",\n                \"after\": \"In Review\",\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-213\",\n                \"field\": \"board_list\",\n                \"after\": \"In Review\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "this-is-truly-a-low-priority-task",
            "problem": "Can you add a 'Low Priority' label to my subtask (not issue) that assesses technical risk in my legacy component ranking ticket? It's in the tech debt project.",
            "category": "label_and_priority_management",
            "difficulty": "easy",
            "verifier_func": "async def validate_this_is_truly_a_low_priority_task(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-711 has the low-priority label\"\"\"\n    # Check that DEBT-711 has the \"Low Priority\" label\n    low_priority_label = after.table(\"labels\").eq(\"name\", \"Low Priority\").first()\n    if not low_priority_label:\n        raise AssertionError(\"Expected 'Low Priority' label to exist\")\n\n    label_id = low_priority_label[\"id\"]\n\n    # Verify DEBT-711 has this label\n    after.table(\"issue_labels\").eq(\"issue_id\", \"DEBT-711\").eq(\n        \"label_id\", label_id\n    ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only expected changes occurred - label creation (if new) and assignment\n    expected_changes = [\n        {\n            \"table\": \"issue_labels\",\n            \"pk\": (\"DEBT-711\", label_id),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Check if the label was newly created\n    before_label = before.table(\"labels\").eq(\"name\", \"Low Priority\").first()\n    if not before_label:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": label_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "finish-blue-green-deployment",
            "problem": "We just finished blue-green deployment. Can you mark it and its parent task as done?",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_finish_blue_green_deployment(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-722 and DEBT-720 are marked as Done\"\"\"\n    # Check final state\n    after.table(\"issues\").eq(\"id\", \"DEBT-722\").assert_eq(\"board_list\", \"Done\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-720\").assert_eq(\"board_list\", \"Done\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Enforce invariant: nothing else changed (with ignore configuration)\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-722\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"DEBT-720\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
        },
        {
            "id": "complete-lazy-loaded-images",
            "problem": "Find the 'Images are lazy loaded' task, mark it and its parent task as completed.",
            "category": "task_status_and_progress_updates",
            "difficulty": "easy",
            "verifier_func": "async def validate_complete_lazy_loaded_images(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-714 and SCRUM-711 are marked as Done\"\"\"\n    # Check final state\n    after.table(\"issues\").eq(\"id\", \"SCRUM-714\").assert_eq(\"board_list\", \"Done\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-711\").assert_eq(\"board_list\", \"Done\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Enforce invariant: nothing else changed (with ignore configuration)\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-714\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-711\",\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE\n"
        }
    ]
}