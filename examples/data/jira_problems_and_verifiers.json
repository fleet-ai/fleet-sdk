{
  "problems": [
    {
      "id": "give-me-more-tasks",
      "problem": "In the engineering project, can you move all the bugs to sprint 3, assign the data pipeline bug to me, and assign all the other bugs to Raj?",
      "category": "task_assignment_and_ownership",
      "difficulty": "hard",
      "verifier_func": "async def validate_give_me_more_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that bugs are moved to sprint 3 and assigned correctly\"\"\"\n    # Get user IDs\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n\n    raj_id = raj_user[\"id\"]\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify SCRUM-555 (data pipeline bug) is assigned to Sarah Kim\n    after.table(\"issues\").eq(\"id\", \"SCRUM-555\").assert_eq(\"owner\", sarah_kim_id)\n\n    # Verify other bugs are assigned to Sarah Kim\n    other_bugs = [\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-790\",\n        \"SCRUM-822\",\n        \"SCRUM-882\",\n        \"SCRUM-897\",\n        \"SCRUM-956\",\n        \"SCRUM-1331\",\n        \"SCRUM-1312\",\n        \"SCRUM-1210\",\n        \"SCRUM-1230\",\n        \"SCRUM-1282\",\n    ]\n    for bug_id in other_bugs:\n        after.table(\"issues\").eq(\"id\", bug_id).assert_eq(\"owner\", raj_id)\n\n    # Verify all bugs are in sprint_3\n    all_bugs = [\"SCRUM-555\"] + other_bugs\n    for bug_id in all_bugs:\n        after.table(\"sprint_issues\").eq(\"issue_id\", bug_id).assert_eq(\n            \"sprint_id\", \"sprint_3\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Assignment changes\n    expected_changes.append(\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-555\",\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        }\n    )\n\n    for bug_id in other_bugs:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": bug_id,\n                \"field\": \"owner\",\n                \"after\": raj_id,\n            }\n        )\n\n    # Sprint changes\n    for bug_id in all_bugs:\n        # Remove from previous sprint\n        before_assignment = before.table(\"sprint_issues\").eq(\"issue_id\", bug_id).first()\n        if before_assignment:\n            old_sprint = before_assignment.get(\"sprint_id\")\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (old_sprint, bug_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        # Add to sprint_3\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_3\", bug_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "convert-to-exponential-story-points",
      "problem": "We're converting into a new system where we're now measuring story points in exponentials (1, 2, 4, 8, 16, etc). Can you round all of my active, planned, and backlogged issues to the nearest exponential story point, rounding up if equidistant, in platform eng?",
      "category": "other",
      "difficulty": "hard",
      "verifier_func": "async def validate_convert_to_exponential_story_points(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate conversion of story points to exponential values (1, 2, 4, 8, 16, etc)\"\"\"\n\n    def is_exponential_of_2(n):\n        \"\"\"Check if n is a power of 2 (1, 2, 4, 8, 16, ...)\"\"\"\n        if n <= 0:\n            return False\n        return (n & (n - 1)) == 0\n\n    def next_exponential(n):\n        \"\"\"Round to nearest exponential (power of 2), rounding up when equidistant\"\"\"\n        if n <= 0:\n            return 1\n        if is_exponential_of_2(n):\n            return n\n\n        # Find the two surrounding powers of 2\n        lower_power = 1\n        while lower_power < n:\n            lower_power *= 2\n        upper_power = lower_power\n        lower_power //= 2\n\n        # Calculate distances to both powers\n        distance_to_lower = n - lower_power\n        distance_to_upper = upper_power - n\n\n        # Round to nearest, with tie-breaking towards higher value\n        if distance_to_lower < distance_to_upper:\n            return lower_power\n        else:  # distance_to_lower >= distance_to_upper (includes equidistant case)\n            return upper_power\n\n    # Get user ID for Sarah Kim\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Get issues that should have been converted (only for Sarah Kim)\n    issues_with_points = (\n        after.table(\"issues\")\n        .neq(\"issue_type\", \"Epic\")\n        .neq(\"issue_type\", \"Subtask\")\n        .eq(\"project_key\", \"SCRUM\")\n        .eq(\"owner\", sarah_kim_id)\n        .not_null(\"story_points\")\n        .all()\n    )\n\n    expected_changes = []\n    conversion_count = 0\n\n    for issue in issues_with_points:\n        issue_id = issue.get(\"id\")\n        new_points = issue.get(\"story_points\")\n\n        # Get original story points from before snapshot\n        original_issue = before.table(\"issues\").eq(\"id\", issue_id).first()\n        if not original_issue:\n            continue  # Skip new issues\n\n        original_points = original_issue.get(\"story_points\")\n        if original_points is None:\n            continue  # Skip issues that didn't have points originally\n\n        # Verify the conversion is correct\n        expected_points = next_exponential(original_points)\n\n        if new_points != expected_points:\n            raise AssertionError(\n                f\"Issue {issue_id}: Expected story points {expected_points} \"\n                f\"(rounded up from {original_points}), got {new_points}\"\n            )\n\n        # Verify it's an exponential value\n        if not is_exponential_of_2(new_points):\n            raise AssertionError(\n                f\"Issue {issue_id}: Story points {new_points} is not an exponential value\"\n            )\n\n        # Only track as a change if the value actually changed\n        if original_points != new_points:\n            expected_changes.append(\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"story_points\",\n                    \"after\": new_points,\n                }\n            )\n            conversion_count += 1\n\n    if conversion_count == 0:\n        raise AssertionError(\n            \"No story points were converted - expected at least some conversions\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only story points changed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "restructure-onboarding-epics",
      "problem": "I want to restructure my platform engineering project. Specifically, I have 5 epics related to onboarding (one for self-serve onboarding portal, one for customer success guided, one for design, one for developing onboarding tools, and one to test and launch). Create a new epic in the platform engineering simply named \"Onboarding\" with a description in my current sprint 1, and then move all of the issues sitting under the 5 epics enumerated in this message into this new Onboarding epic",
      "category": "epic_management_and_organization",
      "difficulty": "hard",
      "verifier_func": "async def validate_restructure_onboarding_epics(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of master 'Onboarding' epic SCRUM-1340 in sprint_1 with all onboarding issues moved under it\"\"\"\n    # Check that SCRUM-1340 exists as an Epic in sprint_1\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"name\", \"Onboarding\")\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1340\").eq(\n        \"sprint_id\", \"sprint_1\"\n    ).assert_exists()\n\n    # Define all the onboarding-related issue IDs that should be under this epic\n    onboarding_issue_ids = [\n        \"SCRUM-766\",\n        \"SCRUM-773\",\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-831\",\n        \"SCRUM-835\",\n        \"SCRUM-839\",\n        \"SCRUM-843\",\n        \"SCRUM-1263\",\n        \"SCRUM-1269\",\n        \"SCRUM-1275\",\n        \"SCRUM-1282\",\n        \"SCRUM-1283\",\n        \"SCRUM-1291\",\n        \"SCRUM-1298\",\n        \"SCRUM-1305\",\n        \"SCRUM-1312\",\n        \"SCRUM-1313\",\n        \"SCRUM-1320\",\n        \"SCRUM-1331\",\n        \"SCRUM-1332\",\n        \"SCRUM-1336\",\n    ]\n\n    # Check that all specified issues have epic_id set to SCRUM-1340\n    for issue_id in onboarding_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + sprint assignment + all issue parent assignments\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"},\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", \"SCRUM-1340\"),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Add epic_id changes for all onboarding issues\n    for issue_id in onboarding_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"SCRUM-1340\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "blocked-by-typescript-migration",
      "problem": "Unfortunately we have to complete our typescript migration before making any more frontend UI improvements. Go into the platform engineering project and find all issues labeled as \"Frontend\". Review every issue; if the issue is not marked as Done, tag the issue as blocked by my typescript migraiton and type safety epic. Ignore any issue marked as Done.",
      "category": "dependency_and_blocking_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_blocked_by_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that frontend issues are blocked by DEBT-793\"\"\"\n    expected_blocked_issues = [\n        \"SCRUM-1269\",\n        \"SCRUM-711\",\n        \"SCRUM-1312\",\n        \"SCRUM-726\",\n        \"SCRUM-855\",\n        \"SCRUM-942\",\n        \"SCRUM-943\",\n        \"SCRUM-1298\",\n        \"SCRUM-731\",\n        \"SCRUM-738\",\n        \"SCRUM-745\",\n        \"SCRUM-753\",\n        \"SCRUM-759\",\n        \"SCRUM-766\",\n        \"SCRUM-773\",\n        \"SCRUM-780\",\n        \"SCRUM-781\",\n        \"SCRUM-782\",\n        \"SCRUM-790\",\n        \"SCRUM-814\",\n        \"SCRUM-823\",\n    ]\n\n    expected_changes = []\n\n    for issue_id in expected_blocked_issues:\n        relationship = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", \"DEBT-793\")\n            .eq(\"target_issue_id\", issue_id)\n            .eq(\"relationship_type\", \"blocks\")\n            .first()\n        )\n\n        if not relationship:\n            raise AssertionError(f\"Expected {issue_id} to be blocked by DEBT-793\")\n\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": relationship[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "comment-on-all-unreplied-issues",
      "problem": "For all support issues in progress where the user hasn't heard from us in >1 day, can you add a comment letting them know we're still on it? To check when the user last heard from us, you may need to scroll down through the issue to see the full back-and-forth.",
      "category": "comments_and_communication",
      "difficulty": "hard",
      "verifier_func": "async def validate_comment_on_all_unreplied_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify multiple support issues have the expected comment counts\"\"\"\n    # Expected comment counts for each issue\n    expected_counts = {\n        \"SUP-404\": 9,\n        \"SUP-407\": 6,\n        \"SUP-410\": 5,\n        \"SUP-417\": 5,\n        \"SUP-430\": 3,\n        \"SUP-435\": 3,\n        \"SUP-442\": 6,\n        \"SUP-445\": 9,\n        \"SUP-499\": 5,\n    }\n\n    new_comment_ids = []\n\n    for issue_id, expected_count in expected_counts.items():\n        # Count public comments for this issue\n        comment_count = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != expected_count:\n            raise AssertionError(\n                f\"Expected {expected_count} public comments on {issue_id}, found {comment_count}\"\n            )\n\n        # Verify exactly one new comment was added\n        before_count = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != before_count + 1:\n            raise AssertionError(\n                f\"Expected comment count to increase by 1 for {issue_id}. Before: {before_count}, After: {comment_count}\"\n            )\n\n        # Find the new comment for this issue\n        all_after_comments = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n        all_before_comments = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n\n        before_ids = {comment[\"id\"] for comment in all_before_comments}\n        new_comments = [\n            comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n        ]\n\n        if len(new_comments) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 new comment for {issue_id}, found {len(new_comments)}\"\n            )\n\n        new_comment_ids.append(new_comments[0][\"id\"])\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes for all new comments\n    expected_changes = [\n        {\n            \"table\": \"activities\",\n            \"pk\": comment_id,\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n        for comment_id in new_comment_ids\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "create-workflow-implemented-tasks",
      "problem": "Can you create an associated issue in the platform engineering project for each of these support tickets: 1) duplicate workflows; 2) export workflow templates; 3) bulk edit workflows; 4) search workflows by content; 5) version control workflows; 6) and real-time collaboration for workflows in product eng? Put it under a new epic, and set each support ticket as implemented by each issue.",
      "category": "task_creation_and_subtask_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_create_workflow_implemented_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that SCRUM-1340 through SCRUM-1345 exist with one epic and implementation relationships\"\"\"\n    issue_ids = [\n        \"SCRUM-1340\",\n        \"SCRUM-1341\",\n        \"SCRUM-1342\",\n        \"SCRUM-1343\",\n        \"SCRUM-1344\",\n        \"SCRUM-1345\",\n        \"SCRUM-1346\",\n    ]\n    support_tickets = [\"SUP-386\", \"SUP-392\", \"SUP-397\", \"SUP-409\", \"SUP-414\", \"SUP-419\"]\n\n    # Verify all issues exist\n    issues = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Expected issue {issue_id} to exist\")\n        issues.append(issue)\n\n    # Find the epic (one issue should have issue_type = \"Epic\")\n    epic_issues = [issue for issue in issues if issue.get(\"issue_type\") == \"Epic\"]\n    if len(epic_issues) != 1:\n        raise AssertionError(f\"Expected exactly 1 epic, found {len(epic_issues)}\")\n\n    epic = epic_issues[0]\n    epic_id = epic[\"id\"]\n\n    # Verify other 5 issues have epic_id pointing to the epic\n    non_epic_issues = [issue for issue in issues if issue.get(\"issue_type\") != \"Epic\"]\n    if len(non_epic_issues) != 6:\n        raise AssertionError(\n            f\"Expected exactly 6 non-epic issues, found {len(non_epic_issues)}\"\n        )\n\n    for issue in non_epic_issues:\n        if issue.get(\"epic_id\") != epic_id:\n            raise AssertionError(\n                f\"Expected issue {issue['id']} to have epic_id {epic_id}, got {issue.get('epic_id')}\"\n            )\n\n    # Verify each support ticket is implemented by exactly one issue (no duplicates)\n    implementation_relationships = []\n    used_issues = set()\n\n    for support_ticket in support_tickets:\n        relationships = (\n            after.table(\"issue_relationships\")\n            .eq(\"source_issue_id\", support_ticket)\n            .eq(\"relationship_type\", \"is_implemented_by\")\n            .all()\n        )\n\n        if len(relationships) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 implementation relationship for {support_ticket}, found {len(relationships)}\"\n            )\n\n        rel = relationships[0]\n        implementing_issue = rel[\"target_issue_id\"]\n\n        if implementing_issue not in issue_ids:\n            raise AssertionError(\n                f\"Expected {support_ticket} to be implemented by one of {issue_ids}, got {implementing_issue}\"\n            )\n\n        if implementing_issue in used_issues:\n            raise AssertionError(\n                f\"Issue {implementing_issue} is implementing multiple support tickets (duplicates not allowed)\"\n            )\n\n        used_issues.add(implementing_issue)\n        implementation_relationships.append(rel)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected changes - 6 new issues and 6 implementation relationships\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    for rel in implementation_relationships:\n        expected_changes.append(\n            {\n                \"table\": \"issue_relationships\",\n                \"pk\": rel[\"id\"],\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "schedule-offline-ui-bugs",
      "problem": "Can you set the issue fix offline mode UI bugs to start in 4 days and to last for 3 days in the timeline view?",
      "category": "other",
      "difficulty": "hard",
      "verifier_func": "async def validate_schedule_offline_ui_bugs(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate scheduling of offline UI bugs issue (SCRUM-1210)\"\"\"\n    issue_id = \"SCRUM-1210\"\n\n    # Get the issue\n    issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n    if not issue:\n        raise AssertionError(f\"Issue {issue_id} not found\")\n\n    hours_ago = issue.get(\"hoursAgo\")\n    duration = issue.get(\"duration\")\n\n    # Validate hoursAgo is -96 (starts in 4 days)\n    if hours_ago != -96:\n        raise AssertionError(\n            f\"Expected hoursAgo as -96 for {issue_id}, got {hours_ago}\"\n        )\n\n    # Validate duration is 72 hours (3 days)\n    if duration != 72:\n        raise AssertionError(\n            f\"Expected duration between 48 and 72 hours for {issue_id}, got {duration}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the scheduling fields changed\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"hoursAgo\",\n                \"after\": hours_ago,\n            },\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"duration\", \"after\": duration},\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "plan-cicd-pipeline-epic",
      "problem": "Can you plan the CI/CD Pipeline Optimization epic? Go to the timeline of the Platform Engineering project, and locate this epic. Considering the blue line marks today in this timeline, use that as a guide to start this epic one week from today and to have it last 15 days. Each of the 5 issues within this epic should also start within this 15 day range, and each task should last 3 days each without any overlap.",
      "category": "other",
      "difficulty": "hard",
      "verifier_func": "async def validate_plan_cicd_pipeline_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning of CI/CD Pipeline Optimization epic (SCRUM-523) and its child issues\"\"\"\n    epic_id = \"SCRUM-523\"\n\n    # Get the epic\n    epic = after.table(\"issues\").eq(\"id\", epic_id).first()\n    if not epic:\n        raise AssertionError(f\"Epic {epic_id} not found\")\n\n    epic_hours_ago = epic.get(\"hoursAgo\")\n    epic_duration = epic.get(\"duration\")\n\n    # Validate epic timing: starts in a week (-168 to -189) and lasts 14 days (312-336 hours)\n    if epic_hours_ago != -168:\n        raise AssertionError(f\"Expected epic hoursAgo to be -168, got {epic_hours_ago}\")\n\n    if epic_duration != 360:\n        raise AssertionError(\n            f\"Expected epic duration to be 360 hours, got {epic_duration}\"\n        )\n\n    # Get child issues of the epic (direct children, not nested subtasks)\n    child_issues = (\n        after.table(\"issues\").eq(\"epic_id\", epic_id).is_null(\"parent_id\").all()\n    )\n\n    if len(child_issues) != 5:\n        raise AssertionError(\n            f\"Expected 5 child issues for epic {epic_id}, found {len(child_issues)}\"\n        )\n\n    # Validate each child issue\n    issue_timings = []\n    for issue in child_issues:\n        issue_id = issue.get(\"id\")\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        # Each issue should start within the epic timeframe and last 2 days (47.9-72 hours)\n        if not (-456 <= hours_ago <= -168):\n            raise AssertionError(\n                f\"Expected issue {issue_id} hoursAgo between -456 and -168, got {hours_ago}\"\n            )\n\n        if duration != 72:\n            raise AssertionError(\n                f\"Expected issue {issue_id} duration to be 72 hours, got {duration}\"\n            )\n\n        issue_timings.append((issue_id, hours_ago, duration))\n\n    # Check for overlaps (no two issues should have overlapping time windows)\n    for i, (id1, start1, dur1) in enumerate(issue_timings):\n        end1 = start1 + dur1\n        for j, (id2, start2, dur2) in enumerate(issue_timings[i + 1 :], i + 1):\n            end2 = start2 + dur2\n            # Check if intervals overlap\n            if not (end1 <= start2 or end2 <= start1):\n                raise AssertionError(\n                    f\"Issues {id1} and {id2} have overlapping schedules: \"\n                    f\"{id1}({start1} to {end1}) overlaps with {id2}({start2} to {end2})\"\n                )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": epic_id,\n            \"field\": \"hoursAgo\",\n            \"after\": epic_hours_ago,\n        },\n        {\"table\": \"issues\", \"pk\": epic_id, \"field\": \"duration\", \"after\": epic_duration},\n    ]\n\n    for issue_id, hours_ago, duration in issue_timings:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": hours_ago,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"duration\",\n                    \"after\": duration,\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "start-ai-workflow-intelligence-project",
      "problem": "I'm looking to start the AI workflow intelligence project. Can you set the timeline of the advanced analytics epic, the AI pattern recognition epic, the conversational UI epic, and the core NLP infra epic to start today and end in 2w, then create a new sprint and move all issues under those epics to the new sprint?",
      "category": "project_and_sprint_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_start_ai_workflow_intelligence_project(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate AI workflow intelligence project timeline and sprint setup\"\"\"\n    # Expected epic IDs that should have hoursAgo = 0, duration = 336\n    epic_ids = [\"AIWORK-125\", \"AIWORK-181\", \"AIWORK-56\", \"AIWORK-1\"]\n\n    # Verify all epics have correct timing\n    for epic_id in epic_ids:\n        issue = after.table(\"issues\").eq(\"id\", epic_id).first()\n        if not issue:\n            raise AssertionError(f\"Epic {epic_id} not found\")\n\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        if hours_ago != 0:\n            raise AssertionError(\n                f\"Epic {epic_id} should have hoursAgo = 0, got {hours_ago}\"\n            )\n\n        if duration != 336:\n            raise AssertionError(\n                f\"Epic {epic_id} should have duration = 336, got {duration}\"\n            )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Find all tasks under these epics (with no parent_id)\n    epic_tasks = []\n    for epic_id in epic_ids:\n        tasks = after.table(\"issues\").eq(\"epic_id\", epic_id).is_null(\"parent_id\").all()\n        epic_tasks.extend([task[\"id\"] for task in tasks])\n\n    # Verify all epic tasks are in sprint_8\n    for task_id in epic_tasks:\n        after.table(\"sprint_issues\").eq(\"issue_id\", task_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic timing changes\n    for epic_id in epic_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": epic_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": 0,\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": epic_id,\n                    \"field\": \"duration\",\n                    \"after\": 336,\n                },\n            ]\n        )\n\n    # Add sprint assignments for epic tasks\n    for task_id in epic_tasks:\n        # Find original sprint assignment\n        before_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", task_id).first()\n        )\n        if before_assignment:\n            old_sprint = before_assignment.get(\"sprint_id\")\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (old_sprint, task_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_8\", task_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "tag-medium-priority-debt",
      "problem": "Can you tag all issues in the active sprint for the tech debt project with \"Medium Priority\" if there's no current priority label? There should only be three.",
      "category": "label_and_priority_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_tag_medium_priority_debt(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-696, DEBT-741, and DEBT-540 have Medium Priority labels\"\"\"\n    issue_ids = [\"DEBT-696\", \"DEBT-741\", \"DEBT-540\"]\n\n    # Get Medium Priority label\n    medium_priority_label = after.table(\"labels\").eq(\"name\", \"Medium Priority\").first()\n    if not medium_priority_label:\n        raise AssertionError(\"Expected 'Medium Priority' label to exist\")\n\n    label_id = medium_priority_label[\"id\"]\n\n    # Verify all issues have the Medium Priority label\n    for issue_id in issue_ids:\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", label_id\n        ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - label assignments for all issues\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (issue_id, label_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Check if the label was newly created\n    before_label = before.table(\"labels\").eq(\"name\", \"Medium Priority\").first()\n    if not before_label:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": label_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "reassign-active-security-tasks",
      "problem": "We just hired Olivia Chen as our new security engineer. Across all my projects, can you re-assign issues labeled \"Security\" in all active sprints to her? I suggest going through every single project and using the filters in the backlog page.",
      "category": "task_assignment_and_ownership",
      "difficulty": "hard",
      "verifier_func": "async def validate_reassign_active_security_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that Security labeled issues in active sprints are assigned to Olivia Chen\"\"\"\n    # Get Olivia Chen's user ID\n    olivia_user = after.table(\"users\").eq(\"name\", \"Olivia Chen\").first()\n    if not olivia_user:\n        raise AssertionError(\"User 'Olivia Chen' not found\")\n    olivia_id = olivia_user[\"id\"]\n\n    # Get Security label\n    security_label = after.table(\"labels\").eq(\"name\", \"Security\").first()\n    if not security_label:\n        raise AssertionError(\"Expected 'Security' label to exist\")\n    security_label_id = security_label[\"id\"]\n\n    # Find all Security labeled issues in active sprints\n    security_issues = (\n        after.table(\"issue_labels\")\n        .eq(\"label_id\", security_label_id)\n        .join(\"sprint_issues\", {\"issue_id\": \"issue_id\"})\n        .in_(\"sprint_id\", [\"sprint_1\", \"sprint_2\", \"sprint_5\"])\n        .all()\n    )\n\n    # Verify all these issues are assigned to Olivia Chen\n    for issue_assignment in security_issues:\n        issue_id = issue_assignment[\"issue_id\"]\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", olivia_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_assignment in security_issues:\n        issue_id = issue_assignment[\"issue_id\"]\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": olivia_id,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "vacation-reassign",
      "problem": "I am going on vacation for the next 7 days. If I have any issues (not epics or subtasks) in the tech debt or platform eng project issues that are set to end before I gets back from vacation, assign them to Thomas. To find these issues, you will go to the 'Timeline' view, open the epics, and scroll to the right to see all tasks projected to end between the blue line (today) and 7 days from now.",
      "category": "task_assignment_and_ownership",
      "difficulty": "hard",
      "verifier_func": "async def validate_vacation_reassign(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that immediate tasks due during vacation are assigned to Thomas Lee\"\"\"\n    # Get user IDs\n    sarah_kim_user = before.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    thomas_user = after.table(\"users\").eq(\"name\", \"Thomas Lee\").first()\n\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    if not thomas_user:\n        raise AssertionError(\"User 'Thomas Lee' not found\")\n\n    sarah_kim_id = sarah_kim_user[\"id\"]\n    thomas_id = thomas_user[\"id\"]\n\n    # Find all issues in DEBT project owned by Sarah Kim that are not Done, not Epic, not Subtask\n    all_issues = before.table(\"issues\").all()\n    sarah_debt_issues = []\n\n    for issue in all_issues:\n        # Check if it's in DEBT project (project_key starts with \"DEBT\")\n        if not issue.get(\"id\", \"\").startswith(\"DEBT-\") and not issue.get(\n            \"id\", \"\"\n        ).startswith(\"SCRUM-\"):\n            continue\n\n        # Check if owned by Sarah Kim\n        if issue.get(\"owner\") != sarah_kim_id:\n            continue\n\n        # Check if not Done\n        if issue.get(\"board_list\") == \"Done\":\n            continue\n\n        # Check if not Epic or Subtask\n        issue_type = issue.get(\"issue_type\", \"\")\n        if issue_type in [\"Epic\", \"Subtask\"]:\n            continue\n\n        sarah_debt_issues.append(issue)\n\n    # Filter for issues due during vacation: -60 < (hoursAgo - duration) <= 0\n    vacation_issues = []\n    for issue in sarah_debt_issues:\n        hours_ago = issue.get(\"hoursAgo\", 0)\n        duration = issue.get(\"duration\", 0)\n\n        if hours_ago is None or duration is None:\n            continue\n\n        time_until_due = hours_ago - duration\n\n        if -156 < time_until_due <= 0:\n            print(issue)\n            vacation_issues.append(issue)\n\n    # Verify all vacation issues are now assigned to Thomas Lee\n    vacation_issue_ids = [issue[\"id\"] for issue in vacation_issues]\n\n    for issue_id in vacation_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", thomas_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in vacation_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": thomas_id,\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "reassign-onboarding-tools-to-raj",
      "problem": "The onboarding tools epic is going to be handled by Raj now. Can you change ownership of every issue sitting within the Develop Onboarding Tools epic to Raj? Also, go through the subtasks for each issue in this epic and assign those subtasks to Raj as well.",
      "category": "task_assignment_and_ownership",
      "difficulty": "hard",
      "verifier_func": "async def validate_reassign_onboarding_tools_to_raj(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1291 through 1319 are assigned to Raj Patel\"\"\"\n    issue_ids = [f\"SCRUM-{i}\" for i in range(1291, 1320)]  # 1291 through 1319\n\n    # Get Raj Patel's user ID\n    raj_patel_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_patel_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_patel_id = raj_patel_user[\"id\"]\n\n    # Check that all issues are assigned to Raj Patel\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_patel_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": raj_patel_id,\n            }\n        )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "plan-sprint-4-mobile",
      "problem": "I want you plan my next sprint (sprint 4) in platform engineering. I want the sprint to accomplish 1 objective: finish the mobile app. Find all mobile-related tasks in the backlog, assign Marcus to them, and move them to the new sprint. The easiest way to find all of these issues is by filtering by the 6 \"Mobile App v2.0\" epics and moving all related issues into the sprint.",
      "category": "project_and_sprint_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_plan_sprint_4_mobile(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate Sprint 4 (id sprint_8) planning with mobile-focused task assignment for Marcus\"\"\"\n\n    # Define expected assignments for Marcus (mobile tasks)\n    marcus_issues = [\n        \"SCRUM-1257\",\n        \"SCRUM-1251\",\n        \"SCRUM-1245\",\n        \"SCRUM-1238\",\n        \"SCRUM-1231\",\n        \"SCRUM-1227\",\n        \"SCRUM-1224\",\n        \"SCRUM-1221\",\n        \"SCRUM-759\",\n        \"SCRUM-753\",\n        \"SCRUM-745\",\n        \"SCRUM-738\",\n        \"SCRUM-731\",\n    ]\n\n    # Get user ID for Marcus\n    marcus_johnson_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n\n    if not marcus_johnson_user:\n        raise AssertionError(\"User 'Marcus Johnson' not found\")\n\n    marcus_johnson_id = marcus_johnson_user[\"id\"]\n\n    # Check each issue is in sprint_8 and has correct owner\n    for issue_id in marcus_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", marcus_johnson_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Sprint creation (if not already existing)\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Issue owner assignments\n    for issue_id in marcus_issues:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": marcus_johnson_id,\n            }\n        )\n\n    # Sprint assignments\n    for issue_id in marcus_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_8\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"backlog\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "reassign-by-capacity",
      "problem": "Can you reassign the 2 largest incomplete tasks by story points from the person with the highest workload to James Wilson in the tech debt project?",
      "category": "task_assignment_and_ownership",
      "difficulty": "hard",
      "verifier_func": "async def validate_reassign_by_capacity(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that the 2 largest incomplete tasks are reassigned to James Wilson\"\"\"\n    issue_ids = [\"DEBT-554\", \"DEBT-576\"]\n\n    # Get James Wilson's user ID\n    james_wilson_user = after.table(\"users\").eq(\"name\", \"James Wilson\").first()\n    if not james_wilson_user:\n        raise AssertionError(\"User 'James Wilson' not found\")\n    james_wilson_id = james_wilson_user[\"id\"]\n\n    # Check that both issues are assigned to James Wilson\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", james_wilson_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": james_wilson_id,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "tag-completed-policies",
      "problem": "Can you tag the two security policy subtasks under my SOC 2 documentation package issue with the same labels as the parent task?",
      "category": "label_and_priority_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_tag_completed_policies(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-177 and DEBT-178 have Compliance and Documentation labels\"\"\"\n    issue_ids = [\"DEBT-177\", \"DEBT-178\"]\n\n    # Get required labels\n    compliance_label = after.table(\"labels\").eq(\"name\", \"Compliance\").first()\n    if not compliance_label:\n        raise AssertionError(\"Expected 'Compliance' label to exist\")\n\n    documentation_label = after.table(\"labels\").eq(\"name\", \"Documentation\").first()\n    if not documentation_label:\n        raise AssertionError(\"Expected 'Documentation' label to exist\")\n\n    compliance_id = compliance_label[\"id\"]\n    documentation_id = documentation_label[\"id\"]\n\n    # Verify both issues have both labels\n    for issue_id in issue_ids:\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", compliance_id\n        ).assert_exists()\n        after.table(\"issue_labels\").eq(\"issue_id\", issue_id).eq(\n            \"label_id\", documentation_id\n        ).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - label assignments for both issues\n    expected_changes = []\n\n    for issue_id in issue_ids:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issue_labels\",\n                    \"pk\": (issue_id, compliance_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"issue_labels\",\n                    \"pk\": (issue_id, documentation_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    # Check if labels were newly created\n    before_compliance = before.table(\"labels\").eq(\"name\", \"Compliance\").first()\n    if not before_compliance:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": compliance_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before_documentation = before.table(\"labels\").eq(\"name\", \"Documentation\").first()\n    if not before_documentation:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": documentation_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "create-fedramp-project-with-sprint-and-tasks",
      "problem": "We're going to start making a push for FedRAMP authorization. Create a new project for this push, which should be named \"FedRAMP Certification\" and use the key FED. To create a project, use the \"+\" button near the \"Projects\" in the sidebar. Within this project, create a new sprint. Finally, we need to create a couple of tasks to framework this project. Create one task called Plan FedRAMP Certification and within this four child tasks: 1) Understand FedRAMP Requirements and Framework; 2) Determine our Authorization Path; 3) Conduct a Readiness Assessment; 4) Assemble Core Documentation and Teams. Start the sprint.",
      "category": "project_and_sprint_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_create_fedramp_project_with_sprint_and_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of FedRAMP Certification project with key FED, active sprint, and 5 tasks\"\"\"\n    # Check project exists with key \"FED\" and name \"FedRAMP Certification\"\n    after.table(\"projects\").eq(\"key\", \"FED\").assert_exists()\n    after.table(\"projects\").eq(\"key\", \"FED\").assert_eq(\"name\", \"FedRAMP Certification\")\n\n    # Check that sprint_8 exists and is active\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_eq(\"status\", \"active\")\n\n    # Check that 5 issues exist for FED project (FED-1 through FED-5)\n    fed_issues = [\"FED-1\", \"FED-2\", \"FED-3\", \"FED-4\", \"FED-5\"]\n    for issue_id in fed_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"project_key\", \"FED\")\n        # Verify all issues are in sprint_8\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).eq(\n            \"sprint_id\", \"sprint_8\"\n        ).assert_exists()\n\n    # Verify FED-2 through FED-5 have FED-1 as parent\n    for issue_id in [\"FED-2\", \"FED-3\", \"FED-4\", \"FED-5\"]:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"parent_id\", \"FED-1\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\"table\": \"projects\", \"pk\": \"FED\", \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    # Add issues and sprint assignments\n    for issue_id in fed_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_8\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "create-offline-capabilities-epic",
      "problem": "Within the platform engineering project, I want you to move ALL issues that discuss working on offline capabilities, offline tasks, offline data access, or any task related to \"offline\" into a new epic called \"Offline Capabilities\". I would suggest doing this in the \"Backlog\" view and search via keyword to find these tasks.",
      "category": "epic_management_and_organization",
      "difficulty": "hard",
      "verifier_func": "async def validate_create_offline_capabilities_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Offline Capabilities' epic SCRUM-1340 with specified issues moved under it\"\"\"\n    # Check that SCRUM-1340 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_eq(\n        \"name\", \"Offline Capabilities\"\n    )\n\n    # Define the offline capability issue IDs that should be under this epic\n    offline_issue_ids = [\n        \"SCRUM-1216\",\n        \"SCRUM-1211\",\n        \"SCRUM-1210\",\n        \"SCRUM-1205\",\n        \"SCRUM-1198\",\n        \"SCRUM-687\",\n        \"SCRUM-686\",\n        \"SCRUM-681\",\n        \"SCRUM-688\",\n        \"SCRUM-675\",\n        \"SCRUM-576\",\n        \"SCRUM-738\",\n        \"SCRUM-689\",\n    ]\n\n    # Check that all specified issues have epic_id set to SCRUM-1340\n    for issue_id in offline_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"SCRUM-1340\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + all issue epic assignments\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"},\n    ]\n\n    # Add epic_id changes for all offline capability issues\n    for issue_id in offline_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"SCRUM-1340\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "reorganize-raj-debt-sprint",
      "problem": "I need you to re-organize my tech debt project's sprint 6. Specifically, Raj is going to be out of office so I need you to go into the Sprint 6 tasks, find all of Raj's tasks in Sprint 6, and then move them into Sprint 7. I like to move sprints using right click.",
      "category": "project_and_sprint_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_reorganize_raj_debt_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate reorganizing tech debt project sprint 6 by moving Raj's tickets to Sprint 7\"\"\"\n\n    # List of Raj's issues that should be moved to sprint_7\n    raj_issues = [\n        \"DEBT-169\",\n        \"DEBT-248\",\n        \"DEBT-280\",\n        \"DEBT-432\",\n        \"DEBT-703\",\n        \"DEBT-720\",\n        \"DEBT-765\",\n    ]\n\n    # Verify all issues are now in sprint_7\n    for issue_id in raj_issues:\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_7\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint reassignments - each issue moves from sprint_6 to sprint_7\n    for issue_id in raj_issues:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_6\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_7\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "support-tickets-workflow-send-customer-messages",
      "problem": "There are a bunch of support tickets about our workflow execution history. They all related to one bug that's now fixed. Can you review each of them, and if our team has not responded to the users ticket or query, you must reply to the user letting them know this is being worked on. However, if one of our team has responded to the user and there are no outstanding questions from the user, don't reply again.",
      "category": "comments_and_communication",
      "difficulty": "hard",
      "verifier_func": "async def validate_support_tickets_workflow_send_customer_messages(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify appropriate comments are sent to customers for workflow history tickets\"\"\"\n    # Issues that should have new comments (excluding ones already replied to)\n    comment_issues_with_counts = {\n        \"SUP-410\": 5,\n        \"SUP-430\": 3,\n        \"SUP-450\": 3,\n        # \"SUP-473\": 3,\n        \"SUP-487\": 3,\n        \"SUP-496\": 3,\n    }\n\n    new_comment_ids = []\n\n    # Verify comment counts for issues that got new comments\n    for issue_id, expected_count in comment_issues_with_counts.items():\n        comment_count = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != expected_count:\n            raise AssertionError(\n                f\"Expected {expected_count} public comments on {issue_id}, found {comment_count}\"\n            )\n\n        # Verify exactly one new comment was added\n        before_count = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .count()\n            .value\n        )\n\n        if comment_count != before_count + 1:\n            raise AssertionError(\n                f\"Expected comment count to increase by 1 for {issue_id}. Before: {before_count}, After: {comment_count}\"\n            )\n\n        # Find the new comment\n        all_after_comments = (\n            after.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n        all_before_comments = (\n            before.table(\"activities\")\n            .eq(\"issue_id\", issue_id)\n            .eq(\"type\", \"Comment\")\n            .eq(\"action\", \"public\")\n            .all()\n        )\n\n        before_ids = {comment[\"id\"] for comment in all_before_comments}\n        new_comments = [\n            comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n        ]\n\n        if len(new_comments) != 1:\n            raise AssertionError(\n                f\"Expected exactly 1 new comment for {issue_id}, found {len(new_comments)}\"\n            )\n\n        new_comment_ids.append(new_comments[0][\"id\"])\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes for all new comments\n    expected_changes = []\n    for comment_id in new_comment_ids:\n        expected_changes.append(\n            {\n                \"table\": \"activities\",\n                \"pk\": comment_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "backend-priority",
      "problem": "Can you make sure every single issue in the platform engineering project currently in an active sprint with existing label \"Backend\" also has a priority-related label? If it doesn't, add the \"Medium Priority\" label. I recommend filtering by the label \"Backend\" to make your life easier. Also, don't accidentally delete labels with the \"x\" button when trying to adding new ones.",
      "category": "label_and_priority_management",
      "difficulty": "hard",
      "verifier_func": "async def validate_backend_priority(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that backend tasks in engineering project have increased priority levels\"\"\"\n    # Get all backend issues that are not Epic or Subtask and are in sprint_1 or sprint_2\n    backend_label = after.table(\"labels\").eq(\"name\", \"Backend\").first()\n    if not backend_label:\n        raise AssertionError(\"Expected 'Backend' label to exist\")\n\n    # Get all issues with Backend label\n    backend_issue_labels = (\n        after.table(\"issue_labels\").eq(\"label_id\", backend_label[\"id\"]).all()\n    )\n    backend_issue_ids = [il[\"issue_id\"] for il in backend_issue_labels]\n\n    # Filter to only include issues that are in sprint_1 or sprint_2\n    sprint_filtered_issues = []\n    for issue_id in backend_issue_ids:\n        sprint_assignment = (\n            after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if sprint_assignment and sprint_assignment[\"sprint_id\"] in [\n            \"sprint_1\",\n            \"sprint_2\",\n        ]:\n            sprint_filtered_issues.append(issue_id)\n\n    # Filter to only include issues that are not Epic or Subtask\n    valid_backend_issues = []\n    for issue_id in sprint_filtered_issues:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if issue and issue[\"issue_type\"] not in [\"Epic\", \"Subtask\"]:\n            valid_backend_issues.append(issue_id)\n\n    if not valid_backend_issues:\n        raise AssertionError(\n            \"No valid backend issues found (non-Epic, non-Subtask, in sprint_1 or sprint_2)\"\n        )\n\n    # Get all priority labels (labels that contain \"Priority\")\n    all_labels = after.table(\"labels\").all()\n    priority_labels = [label for label in all_labels if \"Priority\" in label[\"name\"]]\n\n    if not priority_labels:\n        raise AssertionError(\"No priority labels found\")\n\n    priority_label_ids = [label[\"id\"] for label in priority_labels]\n\n    # Check that each valid backend issue has at least one priority label\n    for issue_id in valid_backend_issues:\n        issue_labels = after.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        issue_label_ids = [il[\"label_id\"] for il in issue_labels]\n\n        has_priority_label = any(\n            label_id in priority_label_ids for label_id in issue_label_ids\n        )\n        if not has_priority_label:\n            raise AssertionError(f\"Issue {issue_id} does not have a priority label\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check for newly created priority labels\n    before_labels = before.table(\"labels\").all()\n    before_label_names = {label[\"name\"] for label in before_labels}\n\n    for priority_label in priority_labels:\n        if priority_label[\"name\"] not in before_label_names:\n            expected_changes.append(\n                {\n                    \"table\": \"labels\",\n                    \"pk\": priority_label[\"id\"],\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                }\n            )\n\n    # Check for new issue-label assignments\n    for issue_id in valid_backend_issues:\n        after_issue_labels = after.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        before_issue_labels = (\n            before.table(\"issue_labels\").eq(\"issue_id\", issue_id).all()\n        )\n\n        after_label_ids = {il[\"label_id\"] for il in after_issue_labels}\n        before_label_ids = {il[\"label_id\"] for il in before_issue_labels}\n\n        new_label_ids = after_label_ids - before_label_ids\n\n        for label_id in new_label_ids:\n            # Only track priority label additions\n            if label_id in priority_label_ids:\n                expected_changes.append(\n                    {\n                        \"table\": \"issue_labels\",\n                        \"pk\": (issue_id, label_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    }\n                )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "organize-issues-under-compliance",
      "problem": "Create a new epic called \"Compliance\". Then, find all tasks in the technical debt project related to SOC II, GDPR, and HIPAA and assign each of them to the Compliance epic you created. To find all these tasks, I'd suggest you go into the backlog view, then filter by \"Epic\" (select the 3 relevant epics).",
      "category": "epic_management_and_organization",
      "difficulty": "hard",
      "verifier_func": "async def validate_organize_issues_under_compliance(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Compliance' epic DEBT-893 with SOC II, GDPR, and HIPAA issues organized under it\"\"\"\n\n    # Check that DEBT-893 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"name\", \"Compliance\")\n\n    # Define the compliance-related issue IDs that should be under this epic\n    compliance_issue_ids = [\n        \"DEBT-164\",\n        \"DEBT-185\",\n        \"DEBT-210\",\n        \"DEBT-222\",\n        \"DEBT-169\",\n        \"DEBT-172\",\n        \"DEBT-186\",\n        \"DEBT-214\",\n        \"DEBT-224\",\n        \"DEBT-176\",\n        \"DEBT-189\",\n        \"DEBT-219\",\n        \"DEBT-229\",\n        \"DEBT-179\",\n    ]\n\n    # Verify all compliance issues are now under the Compliance epic\n    for issue_id in compliance_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"DEBT-893\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + epic_id assignments for all compliance issues\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"DEBT-893\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic_id changes for all compliance issues\n    for issue_id in compliance_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"DEBT-893\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "unify-k8s-issues",
      "problem": "Can you unify all my issues of type \"story\" or \"task\" in the tech debt project with 'Kubernetes' in the name under one single new epic called \"Kubernetes\"?",
      "category": "epic_management_and_organization",
      "difficulty": "medium",
      "verifier_func": "async def validate_unify_k8s_issues(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of 'Kubernetes' epic DEBT-893 with k8s issues unified under it\"\"\"\n\n    # Check that DEBT-893 exists as an Epic with correct name\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_exists()\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"issue_type\", \"Epic\")\n    after.table(\"issues\").eq(\"id\", \"DEBT-893\").assert_eq(\"name\", \"Kubernetes\")\n\n    # Define the k8s issue IDs that should be under this epic\n    k8s_issue_ids = [\"DEBT-418\", \"DEBT-597\"]\n\n    # Verify all k8s issues are now under the Kubernetes epic\n    for issue_id in k8s_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"epic_id\", \"DEBT-893\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes: epic creation + epic_id assignments for k8s issues\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": \"DEBT-893\", \"field\": None, \"after\": \"__added__\"}\n    ]\n\n    # Add epic_id changes for k8s issues\n    for issue_id in k8s_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"epic_id\",\n                \"after\": \"DEBT-893\",\n            }\n        )\n\n    # Verify only expected changes occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "tag-parallel-workflows-backend",
      "problem": "Go to the implement parallel workflows in ai workflow builder issue from the platform engineering project and make sure it's tagged as a Backend task.",
      "category": "label_and_priority_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_tag_parallel_workflows_backend(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-552 has Feature, Enhancement, High Priority, and Backend labels\"\"\"\n    # Check that required labels exist\n    feature_label = after.table(\"labels\").eq(\"name\", \"Feature\").first()\n    enhancement_label = after.table(\"labels\").eq(\"name\", \"Enhancement\").first()\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    backend_label = after.table(\"labels\").eq(\"name\", \"Backend\").first()\n\n    if not feature_label:\n        raise AssertionError(\"Expected 'Feature' label to exist\")\n    if not enhancement_label:\n        raise AssertionError(\"Expected 'Enhancement' label to exist\")\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n    if not backend_label:\n        raise AssertionError(\"Expected 'Backend' label to exist\")\n\n    feature_id = feature_label[\"id\"]\n    enhancement_id = enhancement_label[\"id\"]\n    high_priority_id = high_priority_label[\"id\"]\n    backend_id = backend_label[\"id\"]\n\n    # Verify SCRUM-552 has exactly these four labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", feature_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", enhancement_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").eq(\n        \"label_id\", backend_id\n    ).assert_exists()\n\n    # Verify SCRUM-552 has exactly 4 labels\n    scrum_552_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").count().value\n    )\n    if scrum_552_labels != 4:\n        raise AssertionError(\n            f\"Expected SCRUM-552 to have exactly 4 labels, found {scrum_552_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_feature = before.table(\"labels\").eq(\"name\", \"Feature\").first()\n    before_enhancement = before.table(\"labels\").eq(\"name\", \"Enhancement\").first()\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    before_backend = before.table(\"labels\").eq(\"name\", \"Backend\").first()\n\n    if not before_feature:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": feature_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_enhancement:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": enhancement_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_backend:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": backend_id, \"field\": None, \"after\": \"__added__\"}\n        )\n\n    # Get all labels SCRUM-552 had before and remove them\n    before_scrum_552_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-552\").all()\n    )\n    for old_assignment in before_scrum_552_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", feature_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", enhancement_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-552\", backend_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "set-unlabeled-timeline-typescript-migration",
      "problem": "Under the typescript migration epic in the tech debt project, there are a few issues that aren't yet planned on the timeline. Can you plan them to be within the boundaries of the epic's timeline (meaning leftmost side of the epic's purple bar lines up or is to the left of every one of its children's; rightmost side of the epic's purple bar lines up on or to the left of every one if its children.? You will have to scroll right until the rightmost edge of the purple bar for the typescript migration comes into view.",
      "category": "other",
      "difficulty": "medium",
      "verifier_func": "async def validate_set_unlabeled_timeline_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that unlabeled TypeScript migration issues are planned within epic boundaries\"\"\"\n    # Get the epic's timeline\n    epic = after.table(\"issues\").eq(\"id\", \"DEBT-793\").first()\n    if not epic:\n        raise AssertionError(\"Epic DEBT-793 not found\")\n\n    epic_hours_ago = epic.get(\"hoursAgo\")\n    epic_duration = epic.get(\"duration\")\n    epic_start = epic_hours_ago\n    epic_end = epic_hours_ago - epic_duration\n\n    # Issues that should be planned within epic boundaries\n    issue_ids = [\n        \"DEBT-794\",\n        \"DEBT-799\",\n        \"DEBT-805\",\n        \"DEBT-809\",\n        \"DEBT-814\",\n        \"DEBT-818\",\n        \"DEBT-821\",\n    ]\n\n    # Verify each issue has timing within epic boundaries and is not null\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        hours_ago = issue.get(\"hoursAgo\")\n        duration = issue.get(\"duration\")\n\n        if hours_ago is None or duration is None:\n            raise AssertionError(\n                f\"Issue {issue_id} should have hoursAgo and duration set\"\n            )\n\n        issue_start = hours_ago\n        issue_end = hours_ago - duration\n\n        # Check if issue is within epic boundaries\n        if issue_start > epic_start or issue_end < epic_end:\n            raise AssertionError(\n                f\"Issue {issue_id} (start: {issue_start}, end: {issue_end}) \"\n                f\"is not within epic boundaries (start: {epic_start}, end: {epic_end})\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"hoursAgo\",\n                    \"after\": issue.get(\"hoursAgo\"),\n                },\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"duration\",\n                    \"after\": issue.get(\"duration\"),\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "assign-salesforce-connector-to-self",
      "problem": "I want to pick up and work on the salesforce data connector task. I want you to navigate to this task, assign it to me, and move it into Sprint 2.",
      "category": "task_assignment_and_ownership",
      "difficulty": "medium",
      "verifier_func": "async def validate_assign_salesforce_connector_to_self(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate SCRUM-948 assigned to Sarah Kim and moved to sprint 2\"\"\"\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check assignment and sprint\n    after.table(\"issues\").eq(\"id\", \"SCRUM-948\").assert_eq(\"owner\", sarah_kim_id)\n\n    # Check sprint assignment via sprint_issues table\n    sprint_assignment = after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-948\").first()\n    if not sprint_assignment or sprint_assignment.get(\"sprint_id\") != \"sprint_2\":\n        raise AssertionError(\n            f\"Issue SCRUM-948 should be in sprint_2, \"\n            f\"but is in sprint {sprint_assignment.get('sprint_id') if sprint_assignment else 'none'}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-948\",\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_2\", \"SCRUM-948\"),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    # Also expect removal from previous sprint if it was assigned\n    before_assignment = (\n        before.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-948\").first()\n    )\n    if before_assignment:\n        old_sprint = before_assignment.get(\"sprint_id\")\n        expected_changes.append(\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (old_sprint, \"SCRUM-948\"),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "backlog-task-priority",
      "problem": "I think the value of the highest story point task in the AI workflow intel project is overstated. Change story point of the highest story point issue to be one greater than the next highest issue.",
      "category": "label_and_priority_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_backlog_task_priority(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-159 has story_points set to 35\"\"\"\n    issue_id = \"AIWORK-159\"\n\n    # Verify the issue has 35 story points\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"story_points\", 35)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected change - story points update\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"story_points\",\n            \"after\": 35,\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "create-three-bugs",
      "problem": "Can you create three bugs - one called \"Workflow builder UI flicker\", one called \"Search fails to pop up sometimes\", one called \"Onboarding sometimes stuck on step 3\" with the first two in sprint 1, the last in sprint 2; make all in progress and assign to me in platform eng",
      "category": "task_creation_and_subtask_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_create_three_bugs(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of three specific bugs with correct assignments and sprints\"\"\"\n    # Check bug 1: \"Workflow builder UI flicker\" in sprint_1, assigned to Sarah Kim\n    bug1 = after.table(\"issues\").ilike(\"name\", \"%Workflow builder UI flicker%\").first()\n    if not bug1:\n        raise AssertionError(\"Bug 'Workflow builder UI flicker' not found\")\n\n    # Check sprint assignment via sprint_issues table\n    sprint1_assignment = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug1[\"id\"])\n        .eq(\"sprint_id\", \"sprint_1\")\n        .first()\n    )\n    if not sprint1_assignment:\n        raise AssertionError(f\"Bug {bug1['id']} should be in sprint_1\")\n\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check owner\n    if bug1[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug1['id']} should be assigned to Sarah Kim, got {bug1['owner']}\"\n        )\n\n    # Check bug 2: \"Search fails to pop up sometimes\" in sprint_1, assigned to Sarah Kim\n    bug2 = (\n        after.table(\"issues\")\n        .ilike(\"name\", \"%Search fails to pop up sometimes%\")\n        .first()\n    )\n    if not bug2:\n        raise AssertionError(\"Bug 'Search fails to pop up sometimes' not found\")\n\n    sprint1_assignment2 = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug2[\"id\"])\n        .eq(\"sprint_id\", \"sprint_1\")\n        .first()\n    )\n    if not sprint1_assignment2:\n        raise AssertionError(f\"Bug {bug2['id']} should be in sprint_1\")\n\n    if bug2[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug2['id']} should be assigned to Sarah Kim, got {bug2['owner']}\"\n        )\n\n    # Check bug 3: \"Onboarding sometimes stuck on step 3\" in sprint_2, assigned to Sarah Kim\n    bug3 = (\n        after.table(\"issues\")\n        .ilike(\"name\", \"%Onboarding sometimes stuck on step 3%\")\n        .first()\n    )\n    if not bug3:\n        raise AssertionError(\"Bug 'Onboarding sometimes stuck on step 3' not found\")\n\n    sprint2_assignment = (\n        after.table(\"sprint_issues\")\n        .eq(\"issue_id\", bug3[\"id\"])\n        .eq(\"sprint_id\", \"sprint_2\")\n        .first()\n    )\n    if not sprint2_assignment:\n        raise AssertionError(f\"Bug {bug3['id']} should be in sprint_2\")\n\n    if bug3[\"owner\"] != sarah_kim_id:\n        raise AssertionError(\n            f\"Bug {bug3['id']} should be assigned to Sarah Kim, got {bug3['owner']}\"\n        )\n\n    # Check all are bug type and in progress\n    for bug in [bug1, bug2, bug3]:\n        if bug[\"issue_type\"] != \"Bug\":\n            raise AssertionError(\n                f\"Issue {bug['id']} should be of type Bug, got {bug['issue_type']}\"\n            )\n        if bug[\"board_list\"] != \"In Progress\":\n            raise AssertionError(\n                f\"Bug {bug['id']} should be In Progress, got {bug['board_list']}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\"table\": \"issues\", \"pk\": bug1[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"issues\", \"pk\": bug2[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\"table\": \"issues\", \"pk\": bug3[\"id\"], \"field\": None, \"after\": \"__added__\"},\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", bug1[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_1\", bug2[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n        {\n            \"table\": \"sprint_issues\",\n            \"pk\": (\"sprint_2\", bug3[\"id\"]),\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "move-high-priority-to-in-progress",
      "problem": "Can you move all highest and high priority support from \"To Do\" to \"In progress\" and assign them to me?",
      "category": "task_status_and_progress_updates",
      "difficulty": "medium",
      "verifier_func": "async def validate_move_high_priority_to_in_progress(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate highest and high priority support issues moved to In Progress and assigned to Sarah Kim\"\"\"\n    issue_id = \"SUP-368\"\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Verify issue is assigned to Sarah Kim and in In Progress\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"In Progress\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"owner\",\n            \"after\": sarah_kim_id,\n        },\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"board_list\",\n            \"after\": \"In Progress\",\n        },\n    ]\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "delete-error-recovery-issue",
      "problem": "We're a bit early to include error recovery tasks in our AI workflows project. If you find any error recovery issues in our AI workflows project, can you delete them? Specifically, only delete tasks with \"error\" and \"recovery\" both in its name.",
      "category": "other",
      "difficulty": "medium",
      "verifier_func": "async def validate_delete_error_recovery_issue(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that AIWORK-72 has been deleted\"\"\"\n    issue_ids = [\n        \"AIWORK-72\",\n        \"AIWORK-73\",\n        \"AIWORK-74\",\n        \"AIWORK-43\",\n        \"AIWORK-44\",\n        \"AIWORK-45\",\n    ]\n\n    # Verify the issue no longer exists\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_none()\n\n    # Verify it existed before deletion\n    for issue_id in issue_ids:\n        before.table(\"issues\").eq(\"id\", issue_id).assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"issue_labels\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_watchers\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_voters\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes - issue deletion and any related data\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": None,\n            \"after\": \"__removed__\",\n        }\n        for issue_id in issue_ids\n    ]\n\n    # Check if issue was in any sprint and add sprint removal if needed\n    for issue_id in issue_ids:\n        before_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if before_sprint_assignment:\n            sprint_id = before_sprint_assignment[\"sprint_id\"]\n            expected_changes.append(\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (sprint_id, issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                }\n            )\n\n    # Verify only expected deletions occurred\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "workflow-stuck-reason",
      "problem": "Why is the workflow execution stuck in the initializing state in support? Give me the exact internal note identifying the reason verbatim.",
      "category": "information_retrieval_and_queries",
      "difficulty": "medium",
      "verifier_func": "async def validate_workflow_stuck_reason(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that 'circular dependency in the initialization steps' is in the transcript\"\"\"\n    if transcript is None:\n        raise AssertionError(\"Transcript is required for this validation\")\n\n    last_assistant_message = extract_last_assistant_message(transcript).lower()\n    if (\n        \"the workflow execution is stuck in the initialization phase because of a dependency issue\"\n        not in last_assistant_message\n    ):\n        raise AssertionError(\n            f\"Expected 'circular dependency in the initialization steps' to be mentioned in the transcript.\\n\"\n            f\"Transcript: {transcript[:500]}{'...' if len(transcript) > 500 else ''}\"\n        )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "elastic-search-implementation",
      "problem": "It looks like we're already creating an Elasticsearch cluster for some internal use cases. Can you link and set one of my Elasticsearch issues as implemented by the other? Specifically, the subtasks - not the parent tasks.",
      "category": "dependency_and_blocking_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_elastic_search_implementation(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-206 is implemented by DEBT-292\"\"\"\n    # Check that AIWORK-206 is implemented by DEBT-292\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"AIWORK-206\")\n        .eq(\"target_issue_id\", \"DEBT-292\")\n        .eq(\"relationship_type\", \"is_implemented_by\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected AIWORK-206 to be implemented by DEBT-292\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "reconcile-image-loading-labels",
      "problem": "Can you go in to the improve image loading and caching ticket and check the description? Once you find the priority described within the description, make sure the task has the label \"_ Priority\" (ie \"Low Priority\") in accordance with the description.",
      "category": "label_and_priority_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_reconcile_image_loading_labels(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-711 has Frontend, Performance, and High Priority labels\"\"\"\n    # Check that required labels exist\n    frontend_label = after.table(\"labels\").eq(\"name\", \"Frontend\").first()\n    performance_label = after.table(\"labels\").eq(\"name\", \"Performance\").first()\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n\n    if not frontend_label:\n        raise AssertionError(\"Expected 'Frontend' label to exist\")\n    if not performance_label:\n        raise AssertionError(\"Expected 'Performance' label to exist\")\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n\n    frontend_id = frontend_label[\"id\"]\n    performance_id = performance_label[\"id\"]\n    high_priority_id = high_priority_label[\"id\"]\n\n    # Verify SCRUM-711 has exactly these three labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", frontend_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", performance_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n\n    # Verify SCRUM-711 has exactly 3 labels\n    scrum_711_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").count().value\n    )\n    if scrum_711_labels != 3:\n        raise AssertionError(\n            f\"Expected SCRUM-711 to have exactly 3 labels, found {scrum_711_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_frontend = before.table(\"labels\").eq(\"name\", \"Frontend\").first()\n    before_performance = before.table(\"labels\").eq(\"name\", \"Performance\").first()\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n\n    if not before_frontend:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": frontend_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_performance:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": performance_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Get all labels SCRUM-711 had before and remove them\n    before_scrum_711_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"SCRUM-711\").all()\n    )\n    for old_assignment in before_scrum_711_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", frontend_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", performance_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"SCRUM-711\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "bcrypt-is-the-bingo",
      "problem": "We're on cleanup duty today. Find the user authentication module refactoring ticket, and make sure to create a sub-task to test whether the tech Marcus thinks is the best solution actually works for our use-case. Make sure you include the name of this tech in the new issue's name",
      "category": "task_creation_and_subtask_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_bcrypt_is_the_bingo(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1340 is created and its name includes 'bcrypt'\"\"\"\n    # Check that SCRUM-1340 exists\n    after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").assert_exists()\n\n    # Get the issue and verify name includes \"bcrypt\"\n    issue = after.table(\"issues\").eq(\"id\", \"SCRUM-1340\").first()\n    if not issue:\n        raise AssertionError(\"Issue SCRUM-1340 not found\")\n\n    issue_name = issue.get(\"name\", \"\").lower()\n    if \"bcrypt\" not in issue_name:\n        raise AssertionError(\n            f\"Expected SCRUM-1340 name to include 'bcrypt', got '{issue['name']}'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only the new issue was added\n    before.diff(after, ignore_config).expect_only(\n        [{\"table\": \"issues\", \"pk\": \"SCRUM-1340\", \"field\": None, \"after\": \"__added__\"}]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "raj-comment-to-task",
      "problem": "Can you turn Raj's last comment in the workflow optimization recommendation system task into a new task in the same project? You can assign it to Raj Patel. Add the comment verbatim into the description.",
      "category": "task_creation_and_subtask_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_raj_comment_to_task(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate creation of new task from Raj's comment\"\"\"\n    # Find the new task AIWORK-288\n    new_task = after.table(\"issues\").eq(\"id\", \"AIWORK-288\").first()\n\n    if not new_task:\n        raise AssertionError(\"Expected new task to be AIWORK-288\")\n\n    # Get Raj Patel's user ID\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    raj_id = raj_user[\"id\"]\n\n    # Verify task is assigned to Raj Patel\n    if new_task[\"owner\"] != raj_id:\n        raise AssertionError(\n            f\"Expected new task to be assigned to Raj Patel, got {new_task['owner']}\"\n        )\n\n    # Verify project_key is AIWORK\n    if new_task[\"project_key\"] != \"AIWORK\":\n        raise AssertionError(\n            f\"Expected new task to have project_key 'AIWORK', got {new_task['project_key']}\"\n        )\n\n    # Verify description includes the expected text\n    expected_description_text = \"Yes, that's a key use case. We'll compare customer workflows against our template library and successful peer implementations to identify replacement opportunities.\"\n    if expected_description_text not in new_task.get(\"description\", \"\"):\n        raise AssertionError(\n            f\"Expected task description to include '{expected_description_text}', got '{new_task.get('description', '')}'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": new_task[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "blocked-by-cicd-tasks",
      "problem": "Can you set my task for CI/CD pipeline optimization with spot instances to being blocked by my CI/CD pipeline optimization epic? They're in separate projects.",
      "category": "dependency_and_blocking_management",
      "difficulty": "medium",
      "verifier_func": "async def validate_blocked_by_cicd_tasks(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-667 is blocked by SCRUM-523\"\"\"\n    # Check that DEBT-667 is blocked by SCRUM-523\n    relationship = (\n        after.table(\"issue_relationships\")\n        .eq(\"source_issue_id\", \"SCRUM-523\")\n        .eq(\"target_issue_id\", \"DEBT-667\")\n        .eq(\"relationship_type\", \"blocks\")\n        .first()\n    )\n\n    if not relationship:\n        raise AssertionError(\"Expected DEBT-667 to be blocked by SCRUM-523\")\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issue_relationships\": {\"id\", \"created_at\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify expected changes\n    expected_changes = [\n        {\n            \"table\": \"issue_relationships\",\n            \"pk\": relationship[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        },\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "rename-epic",
      "problem": "Can you rename my Improve AI workflow builder performance improvements epic to \"Workflow Builder v2\", change the description too while you're at it? Remember, you have to click on the edit icon to edit the title.",
      "category": "epic_management_and_organization",
      "difficulty": "easy",
      "verifier_func": "async def validate_rename_epic(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-493 is renamed to 'Workflow Builder v2'\"\"\"\n    # Check final state\n    after.table(\"issues\").eq(\"id\", \"SCRUM-493\").assert_eq(\"name\", \"Workflow Builder v2\")\n\n    # Configure ignore settings for this validation\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"boards\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Get the description from the after state\n    issue_after = after.table(\"issues\").eq(\"id\", \"SCRUM-493\").first()\n    description_after = issue_after[\"description\"] if issue_after else None\n\n    # Enforce invariant: only the name and description fields of SCRUM-493 changed\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": \"SCRUM-493\",\n            \"field\": \"name\",\n            \"after\": \"Workflow Builder v2\",\n        },\n    ]\n\n    if description_after is not None:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-493\",\n                \"field\": \"description\",\n                \"after\": description_after,\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "forgetful-customer-support",
      "problem": "I forget what customer I was talking with - which Mark was it that was having problems with workflow scheduling? Give me his full name.",
      "category": "information_retrieval_and_queries",
      "difficulty": "easy",
      "verifier_func": "async def validate_forgetful_customer_support(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that 'Mark Yang' is mentioned in the transcript\"\"\"\n    if transcript is None:\n        raise AssertionError(\"Transcript is required for this validation\")\n\n    last_assistant_message = extract_last_assistant_message(transcript).lower()\n    if \"mark yang\" not in last_assistant_message:\n        raise AssertionError(\n            f\"Expected 'Mark Yang' to be mentioned in the transcript.\\n\"\n            f\"Transcript: {transcript[:500]}{'...' if len(transcript) > 500 else ''}\"\n        )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "take-raj-off-bigquery",
      "problem": "We're taking Raj off of bigquery tasks so that he can focus on his work data processing pipeline. I need you to go into Raj's BigQuery optimization ticket and re-assign all of his tasks and sub-tasks to me that aren't already marked Done. If anyone else is assigned to tasks, leave them as-is, the other assignees can handle those tasks.",
      "category": "task_assignment_and_ownership",
      "difficulty": "easy",
      "verifier_func": "async def validate_take_raj_off_bigquery(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that Raj's BigQuery tasks (DEBT-621, DEBT-625) are reassigned to Sarah Kim\"\"\"\n    issue_ids = [\"DEBT-621\", \"DEBT-625\"]\n\n    # Get Sarah Kim's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Check that the specified issues are assigned to Sarah Kim and not marked Done\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if not issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        # Only reassign if not already Done\n        if issue.get(\"board_list\") != \"Done\":\n            after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_kim_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list for issues that were reassigned\n    expected_changes = []\n    for issue_id in issue_ids:\n        issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        if issue and issue.get(\"board_list\") != \"Done\":\n            expected_changes.append(\n                {\n                    \"table\": \"issues\",\n                    \"pk\": issue_id,\n                    \"field\": \"owner\",\n                    \"after\": sarah_kim_id,\n                }\n            )\n\n    # Enforce invariant: only ownership changes allowed\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "punt-some-tasks-to-later-sprints",
      "problem": "We're falling behind on some work in the platform engineering project so we need to re-organize our sprints. Move the ai workflow builder tasks that haven't been started yet from sprint 1 to sprint 2, and then move both the research test automation tools and the implement test automation framework tasks to the next upcoming planned sprint.",
      "category": "project_and_sprint_management",
      "difficulty": "easy",
      "verifier_func": "async def validate_punt_some_tasks_to_later_sprints(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate sprint reassignments: SCRUM-530 to sprint_2, SCRUM-1156 and SCRUM-1164 to sprint_3\"\"\"\n    # Verify SCRUM-530 is in sprint_2\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-530\").assert_eq(\n        \"sprint_id\", \"sprint_2\"\n    )\n\n    # Verify SCRUM-1156 and SCRUM-1164 are in sprint_3\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1156\").assert_eq(\n        \"sprint_id\", \"sprint_3\"\n    )\n    after.table(\"sprint_issues\").eq(\"issue_id\", \"SCRUM-1164\").assert_eq(\n        \"sprint_id\", \"sprint_3\"\n    )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\", \"sprint_issues\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Handle SCRUM-530 move from sprint_1 to sprint_2\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_1\", \"SCRUM-530\"),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            },\n            {\n                \"table\": \"sprint_issues\",\n                \"pk\": (\"sprint_2\", \"SCRUM-530\"),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    # Handle SCRUM-1156 and SCRUM-1164 moves from sprint_2 to sprint_3\n    for issue_id in [\"SCRUM-1156\", \"SCRUM-1164\"]:\n        expected_changes.extend(\n            [\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_2\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__removed__\",\n                },\n                {\n                    \"table\": \"sprint_issues\",\n                    \"pk\": (\"sprint_3\", issue_id),\n                    \"field\": None,\n                    \"after\": \"__added__\",\n                },\n            ]\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "plan-first-ai-workflow-platform-sprint",
      "problem": "I want to get started on my AI workflow intelligence platform. Can you plan sprint 1? First, create a new sprint in the AI workflow project. Then, find all of the issues that sit under the core NLP infra epic. Next, move all of these tasks into the new sprint you created. Finally, assign each of these tasks to whoever reported the issue.",
      "category": "project_and_sprint_management",
      "difficulty": "easy",
      "verifier_func": "async def validate_plan_first_ai_workflow_platform_sprint(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate planning sprint 1 for AI workflow platform with epic-based assignments\"\"\"\n\n    # Define issue assignments based on who reported them\n    raj_issues = [\n        \"AIWORK-2\",\n        \"AIWORK-11\",\n    ]\n    elena_issues = [\n        \"AIWORK-6\",\n        \"AIWORK-22\",\n    ]\n    marcus_issues = [\"AIWORK-17\"]\n\n    all_sprint_8_issues = raj_issues + elena_issues + marcus_issues\n\n    # Get user IDs for the assignees\n    raj_user = after.table(\"users\").eq(\"name\", \"Raj Patel\").first()\n    elena_user = after.table(\"users\").eq(\"name\", \"Elena Rodriguez\").first()\n    marcus_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n\n    if not raj_user:\n        raise AssertionError(\"User 'Raj Patel' not found\")\n    if not elena_user:\n        raise AssertionError(\"User 'Elena Rodriguez' not found\")\n    if not marcus_user:\n        raise AssertionError(\"User 'Marcus Johnson' not found\")\n\n    raj_id = raj_user[\"id\"]\n    elena_id = elena_user[\"id\"]\n    marcus_id = marcus_user[\"id\"]\n\n    # Check each issue is in sprint_8 and has correct owner\n    for issue_id in raj_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", raj_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    for issue_id in elena_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", elena_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    for issue_id in marcus_issues:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", marcus_id)\n        after.table(\"sprint_issues\").eq(\"issue_id\", issue_id).assert_eq(\n            \"sprint_id\", \"sprint_8\"\n        )\n\n    # Verify sprint_8 exists\n    after.table(\"sprints\").eq(\"id\", \"sprint_8\").assert_exists()\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprints\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes list\n    expected_changes = []\n\n    # Sprint creation\n    expected_changes.append(\n        {\"table\": \"sprints\", \"pk\": \"sprint_8\", \"field\": None, \"after\": \"__added__\"}\n    )\n\n    # Issue owner assignments\n    for issue_id in raj_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": raj_id}\n        )\n    for issue_id in elena_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": elena_id}\n        )\n    for issue_id in marcus_issues:\n        expected_changes.append(\n            {\"table\": \"issues\", \"pk\": issue_id, \"field\": \"owner\", \"after\": marcus_id}\n        )\n\n    # Sprint assignments\n    for issue_id in all_sprint_8_issues:\n        # Find the original sprint for this issue\n        original_sprint_assignment = (\n            before.table(\"sprint_issues\").eq(\"issue_id\", issue_id).first()\n        )\n        if original_sprint_assignment:\n            original_sprint_id = original_sprint_assignment[\"sprint_id\"]\n            expected_changes.extend(\n                [\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (original_sprint_id, issue_id),\n                        \"field\": None,\n                        \"after\": \"__removed__\",\n                    },\n                    {\n                        \"table\": \"sprint_issues\",\n                        \"pk\": (\"sprint_8\", issue_id),\n                        \"field\": None,\n                        \"after\": \"__added__\",\n                    },\n                ]\n            )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "find-and-comment-on-unassigned-ticket",
      "problem": "Find the unassigned incident support ticket and leave a comment to let the client know that we're on the case.",
      "category": "comments_and_communication",
      "difficulty": "easy",
      "verifier_func": "async def validate_find_and_comment_on_unassigned_ticket(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SUP-368 has one more comment than before\"\"\"\n    # Count comments for SUP-368\n    comment_count = (\n        after.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-368\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    # Verify exactly one new comment was added\n    before_count = (\n        before.table(\"activities\")\n        .eq(\"issue_id\", \"SUP-368\")\n        .eq(\"type\", \"Comment\")\n        .count()\n        .value\n    )\n\n    if comment_count != before_count + 1:\n        raise AssertionError(\n            f\"Expected comment count to increase by 1 for SUP-368. \"\n            f\"Before: {before_count}, After: {comment_count}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Find the new comment\n    all_after_comments = (\n        after.table(\"activities\").eq(\"issue_id\", \"SUP-368\").eq(\"type\", \"Comment\").all()\n    )\n    all_before_comments = (\n        before.table(\"activities\").eq(\"issue_id\", \"SUP-368\").eq(\"type\", \"Comment\").all()\n    )\n\n    before_ids = {comment[\"id\"] for comment in all_before_comments}\n    new_comments = [\n        comment for comment in all_after_comments if comment[\"id\"] not in before_ids\n    ]\n\n    if len(new_comments) != 1:\n        raise AssertionError(\n            f\"Expected exactly 1 new comment, found {len(new_comments)}\"\n        )\n\n    new_comment_id = new_comments[0][\"id\"]\n\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"activities\",\n                \"pk\": new_comment_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "add-mobile-subtasks-to-marcus",
      "problem": "Marcus has been making great progress on improving app startup time so let's give him more work. Go into the backlog to search for the mobile apps issues and find: 1) the two factor auth issue; and 2) the biometric auth issue. Once you found them, assign them to Marcus.",
      "category": "task_assignment_and_ownership",
      "difficulty": "easy",
      "verifier_func": "async def validate_add_mobile_subtasks_to_marcus(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-731 and SCRUM-745 are now owned by Marcus Johnson\"\"\"\n    # Get Marcus Johnson's user ID\n    marcus_user = after.table(\"users\").eq(\"name\", \"Marcus Johnson\").first()\n    if not marcus_user:\n        raise AssertionError(\"Marcus Johnson user not found\")\n    marcus_user_id = marcus_user[\"id\"]\n\n    # Check both issues now have Marcus as owner\n    after.table(\"issues\").eq(\"id\", \"SCRUM-731\").assert_eq(\"owner\", marcus_user_id)\n    after.table(\"issues\").eq(\"id\", \"SCRUM-745\").assert_eq(\"owner\", marcus_user_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"id\", \"updated_at\", \"created_at\", \"rowid\"},\n            \"projects\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"sprint_issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Verify only epic_id and owner fields changed\n    before.diff(after, ignore_config).expect_only(\n        [\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-731\",\n                \"field\": \"owner\",\n                \"after\": marcus_user_id,\n            },\n            {\n                \"table\": \"issues\",\n                \"pk\": \"SCRUM-745\",\n                \"field\": \"owner\",\n                \"after\": marcus_user_id,\n            },\n        ]\n    )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "fix-my-lazy-mistake",
      "problem": "I got a bit lazy writing up task names in my research automation tools task. Can you go in and edit the titles of the ease of use, scalability, and cost tasks to be more expository and high signal for our users? Remember, you have to click on the edit icon to edit the title. ",
      "category": "task_creation_and_subtask_management",
      "difficulty": "easy",
      "verifier_func": "async def validate_fix_my_lazy_mistake(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that SCRUM-1161, SCRUM-1162, SCRUM-1163 have updated names (longer than before)\"\"\"\n    issue_ids = [\"SCRUM-1161\", \"SCRUM-1162\", \"SCRUM-1163\"]\n\n    # Verify all issues have longer names than before\n    for issue_id in issue_ids:\n        before_issue = before.table(\"issues\").eq(\"id\", issue_id).first()\n        after_issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n\n        if not before_issue or not after_issue:\n            raise AssertionError(f\"Issue {issue_id} not found\")\n\n        before_name_length = len(before_issue.get(\"name\", \"\"))\n        after_name_length = len(after_issue.get(\"name\", \"\"))\n\n        if after_name_length <= before_name_length:\n            raise AssertionError(\n                f\"Expected {issue_id} name to be longer. Before: {before_name_length}, After: {after_name_length}\"\n            )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        after_issue = after.table(\"issues\").eq(\"id\", issue_id).first()\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"name\",\n                \"after\": after_issue[\"name\"],\n            }\n        )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "tag-multi-language-nlp-task",
      "problem": "Go to the multi-lanuage nlp models issue from the AI workflow project and make sure it's tagged as a Translation task.",
      "category": "label_and_priority_management",
      "difficulty": "easy",
      "verifier_func": "async def validate_tag_multi_language_nlp_task(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that AIWORK-107 has High Priority, Machine Learning, Multi-Language, NLP, and Translation labels\"\"\"\n    # Check that required labels exist\n    high_priority_label = after.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    ml_label = after.table(\"labels\").eq(\"name\", \"Machine Learning\").first()\n    multi_lang_label = after.table(\"labels\").eq(\"name\", \"Multi-Language\").first()\n    nlp_label = after.table(\"labels\").eq(\"name\", \"NLP\").first()\n    translation_label = after.table(\"labels\").eq(\"name\", \"Translation\").first()\n\n    if not high_priority_label:\n        raise AssertionError(\"Expected 'High Priority' label to exist\")\n    if not ml_label:\n        raise AssertionError(\"Expected 'Machine Learning' label to exist\")\n    if not multi_lang_label:\n        raise AssertionError(\"Expected 'Multi-Language' label to exist\")\n    if not nlp_label:\n        raise AssertionError(\"Expected 'NLP' label to exist\")\n    if not translation_label:\n        raise AssertionError(\"Expected 'Translation' label to exist\")\n\n    high_priority_id = high_priority_label[\"id\"]\n    ml_id = ml_label[\"id\"]\n    multi_lang_id = multi_lang_label[\"id\"]\n    nlp_id = nlp_label[\"id\"]\n    translation_id = translation_label[\"id\"]\n\n    # Verify AIWORK-107 has exactly these five labels\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", high_priority_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", ml_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", multi_lang_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", nlp_id\n    ).assert_exists()\n    after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").eq(\n        \"label_id\", translation_id\n    ).assert_exists()\n\n    # Verify AIWORK-107 has exactly 5 labels\n    aiwork_107_labels = (\n        after.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").count().value\n    )\n    if aiwork_107_labels != 5:\n        raise AssertionError(\n            f\"Expected AIWORK-107 to have exactly 5 labels, found {aiwork_107_labels}\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"issue_labels\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n\n    # Check if labels were newly created\n    before_high_priority = before.table(\"labels\").eq(\"name\", \"High Priority\").first()\n    before_ml = before.table(\"labels\").eq(\"name\", \"Machine Learning\").first()\n    before_multi_lang = before.table(\"labels\").eq(\"name\", \"Multi-Language\").first()\n    before_nlp = before.table(\"labels\").eq(\"name\", \"NLP\").first()\n    before_translation = before.table(\"labels\").eq(\"name\", \"Translation\").first()\n\n    if not before_high_priority:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": high_priority_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_ml:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": ml_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_multi_lang:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": multi_lang_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n    if not before_nlp:\n        expected_changes.append(\n            {\"table\": \"labels\", \"pk\": nlp_id, \"field\": None, \"after\": \"__added__\"}\n        )\n    if not before_translation:\n        expected_changes.append(\n            {\n                \"table\": \"labels\",\n                \"pk\": translation_id,\n                \"field\": None,\n                \"after\": \"__added__\",\n            }\n        )\n\n    # Get all labels AIWORK-107 had before and remove them\n    before_aiwork_107_labels = (\n        before.table(\"issue_labels\").eq(\"issue_id\", \"AIWORK-107\").all()\n    )\n    for old_assignment in before_aiwork_107_labels:\n        expected_changes.append(\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (old_assignment[\"issue_id\"], old_assignment[\"label_id\"]),\n                \"field\": None,\n                \"after\": \"__removed__\",\n            }\n        )\n\n    # Add new label assignments\n    expected_changes.extend(\n        [\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", high_priority_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", ml_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", multi_lang_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", nlp_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n            {\n                \"table\": \"issue_labels\",\n                \"pk\": (\"AIWORK-107\", translation_id),\n                \"field\": None,\n                \"after\": \"__added__\",\n            },\n        ]\n    )\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "james-conference-reassign",
      "problem": "James Wilson is out for a conference right now. Can you re-assign all of his support tickets in progress to me?",
      "category": "task_status_and_progress_updates",
      "difficulty": "easy",
      "verifier_func": "async def validate_james_conference_reassign(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that James Wilson's support tickets are reassigned to Sarah Kim\"\"\"\n    expected_issue_ids = [\"SUP-417\", \"SUP-447\", \"SUP-457\"]\n\n    # Get Sarah Kim's user ID\n    sarah_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_id = sarah_user[\"id\"]\n\n    # Verify all issues are assigned to Sarah Kim\n    for issue_id in expected_issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"owner\", sarah_id)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in expected_issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"owner\",\n                \"after\": sarah_id,\n            }\n        )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "increase-estimate-typescript-migration",
      "problem": "I think we're massively underestimating the typescript migration epic. Can you increase the estimated story points to 3 months (180 story points)?",
      "category": "label_and_priority_management",
      "difficulty": "easy",
      "verifier_func": "async def validate_increase_estimate_typescript_migration(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Verify that DEBT-793 has story_points set to 180\"\"\"\n    issue_id = \"DEBT-793\"\n\n    # Verify the issue has 180 story points\n    after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"story_points\", 180)\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"activities\", \"pageviews\"},\n        table_fields={\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Expected change - story points update\n    expected_changes = [\n        {\n            \"table\": \"issues\",\n            \"pk\": issue_id,\n            \"field\": \"story_points\",\n            \"after\": 180,\n        }\n    ]\n\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "most-frequent-interfaced-customer",
      "problem": "Out of my completed support tickets assigned to David Zhang, can you check and tell me which customer he's interfaced with most frequently?",
      "category": "information_retrieval_and_queries",
      "difficulty": "easy",
      "verifier_func": "async def validate_most_frequent_interfaced_customer(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that 'Robert Taylor' is mentioned in the transcript\"\"\"\n    if transcript is None:\n        raise AssertionError(\"Transcript is required for this validation\")\n\n    last_assistant_message = extract_last_assistant_message(transcript).lower()\n    if \"robert taylor\" not in last_assistant_message:\n        raise AssertionError(\n            f\"Expected 'Robert Taylor' to be mentioned in the transcript.\\n\"\n            f\"Transcript: {transcript[:500]}{'...' if len(transcript) > 500 else ''}\"\n        )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "answer-most-in-progress",
      "problem": "Across all my projects, who has the most epics, issues, and subtasks in progress? How many is that? Give me the full name of the user, and the number of in progress tasks they have currently.",
      "category": "information_retrieval_and_queries",
      "difficulty": "easy",
      "verifier_func": "async def validate_answer_most_in_progress(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that 'Sarah Kim, 30' is mentioned in the transcript\"\"\"\n    if transcript is None:\n        raise AssertionError(\"Transcript is required for this validation\")\n\n    last_assistant_message = extract_last_assistant_message(transcript).lower()\n    if \"sarah kim\" not in last_assistant_message or \"30\" not in last_assistant_message:\n        raise AssertionError(\n            f\"Expected 'Sarah Kim' and '30' to be mentioned in the transcript.\\n\"\n            f\"Transcript: {transcript[:500]}{'...' if len(transcript) > 500 else ''}\"\n        )\n\n    return TASK_SUCCESSFUL_SCORE"
    },
    {
      "id": "iscf-mark-done",
      "problem": "Can you mark all the to-do and in progress subtasks to done in the Implement Security Control Framework issue, mark the entire task as done, and tag Thomas Lee telling him that Im done?",
      "category": "task_status_and_progress_updates",
      "difficulty": "easy",
      "verifier_func": "async def validate_iscf_mark_done(\n    before: DatabaseSnapshot,\n    after: DatabaseSnapshot,\n    transcript: str | None = None,\n) -> int:\n    \"\"\"Validate that DEBT-164 through DEBT-168 are marked as Done and Elena Rodriguez leaves a comment\"\"\"\n    issue_ids = [\"DEBT-164\", \"DEBT-165\", \"DEBT-166\", \"DEBT-167\", \"DEBT-168\"]\n\n    # Verify all issues are marked as Done\n    for issue_id in issue_ids:\n        after.table(\"issues\").eq(\"id\", issue_id).assert_eq(\"board_list\", \"Done\")\n\n    # Get Elena Rodriguez's user ID\n    sarah_kim_user = after.table(\"users\").eq(\"name\", \"Sarah Kim\").first()\n    if not sarah_kim_user:\n        raise AssertionError(\"User 'Sarah Kim' not found\")\n    sarah_kim_id = sarah_kim_user[\"id\"]\n\n    # Find a comment from Elena Rodriguez that mentions \"@Thomas Lee\" and \"done\"\n    comments = (\n        after.table(\"activities\").eq(\"type\", \"Comment\").eq(\"author\", sarah_kim_id).all()\n    )\n\n    found_comment = None\n    for comment in comments:\n        details = comment.get(\"details\", \"\").lower()\n        if \"@thomas lee\" in details.lower() and \"done\" in details.lower():\n            found_comment = comment\n            break\n\n    if not found_comment:\n        raise AssertionError(\n            \"Expected comment from Sarah Kim mentioning '@Thomas Lee' and 'done'\"\n        )\n\n    # Configure ignore settings\n    ignore_config = IgnoreConfig(\n        tables={\"pageviews\", \"activities\"},\n        table_fields={\n            \"activities\": {\"id\", \"rowid\"},\n            \"issues\": {\"updated_at\", \"created_at\", \"rowid\"},\n            \"users\": {\"updated_at\", \"created_at\", \"rowid\"},\n        },\n    )\n\n    # Build expected changes\n    expected_changes = []\n    for issue_id in issue_ids:\n        expected_changes.append(\n            {\n                \"table\": \"issues\",\n                \"pk\": issue_id,\n                \"field\": \"board_list\",\n                \"after\": \"Done\",\n            }\n        )\n\n    # Add the comment\n    expected_changes.append(\n        {\n            \"table\": \"activities\",\n            \"pk\": found_comment[\"id\"],\n            \"field\": None,\n            \"after\": \"__added__\",\n        }\n    )\n\n    # Enforce invariant\n    before.diff(after, ignore_config).expect_only(expected_changes)\n\n    return TASK_SUCCESSFUL_SCORE"
    }
  ]
}